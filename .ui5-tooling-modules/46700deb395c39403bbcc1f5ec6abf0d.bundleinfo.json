{
  "_entries": [
    {
      "name": "clickup_api",
      "path": "C:\\VSCodeRepo\\MCADATA\\Sapui5_ImportLib\\node_modules\\clickup_api\\src\\index.js",
      "lastModified": 1725044136883,
      "type": "module",
      "code": "sap.ui.define((function () { 'use strict';\n\n\tfunction getAugmentedNamespace(n) {\n\t  if (n.__esModule) return n;\n\t  var f = n.default;\n\t\tif (typeof f == \"function\") {\n\t\t\tvar a = function a () {\n\t\t\t\tif (this instanceof a) {\n\t        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t\t}\n\t\t\t\treturn f.apply(this, arguments);\n\t\t\t};\n\t\t\ta.prototype = f.prototype;\n\t  } else a = {};\n\t  Object.defineProperty(a, '__esModule', {value: true});\n\t\tObject.keys(n).forEach(function (k) {\n\t\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn n[k];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn a;\n\t}\n\n\tvar Attachments$2 = function (token, attachment) {\n\t\tthis.token = token;\n\t\tthis.Attachment = attachment;\n\t};\n\t/**\n\t * Upload a file in task Clickup\n\t * @param {String} task_id Task_id to add the file\n\t * @param {String} file_path The path of the file, use path module\n\t * @param {String} file_name Name of the file on Clickup\n\t * @param {String} file_content_type The MIME type of the file\n\t * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\n\t */\n\tAttachments$2.prototype.post_task_attachment = function (\n\t\ttask_id,\n\t\tfile_path,\n\t\tfile_name,\n\t\tfile_content_type\n\t) {\n\t\tvar token = this.token;\n\t\tvar attachment = this.Attachment;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await attachment.post_task_attachment(\n\t\t\t\t\ttask_id,\n\t\t\t\t\tfile_path,\n\t\t\t\t\tfile_name,\n\t\t\t\t\tfile_content_type,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Attachments_1 = Attachments$2;\n\n\tvar global$1 = (typeof global !== \"undefined\" ? global :\n\t  typeof self !== \"undefined\" ? self :\n\t  typeof window !== \"undefined\" ? window : {});\n\n\tvar lookup = [];\n\tvar revLookup = [];\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\tvar inited = false;\n\tfunction init () {\n\t  inited = true;\n\t  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t  for (var i = 0, len = code.length; i < len; ++i) {\n\t    lookup[i] = code[i];\n\t    revLookup[code.charCodeAt(i)] = i;\n\t  }\n\n\t  revLookup['-'.charCodeAt(0)] = 62;\n\t  revLookup['_'.charCodeAt(0)] = 63;\n\t}\n\n\tfunction toByteArray (b64) {\n\t  if (!inited) {\n\t    init();\n\t  }\n\t  var i, j, l, tmp, placeHolders, arr;\n\t  var len = b64.length;\n\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  arr = new Arr(len * 3 / 4 - placeHolders);\n\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len;\n\n\t  var L = 0;\n\n\t  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n\t    arr[L++] = (tmp >> 16) & 0xFF;\n\t    arr[L++] = (tmp >> 8) & 0xFF;\n\t    arr[L++] = tmp & 0xFF;\n\t  }\n\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n\t    arr[L++] = tmp & 0xFF;\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n\t    arr[L++] = (tmp >> 8) & 0xFF;\n\t    arr[L++] = tmp & 0xFF;\n\t  }\n\n\t  return arr\n\t}\n\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp;\n\t  var output = [];\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t    output.push(tripletToBase64(tmp));\n\t  }\n\t  return output.join('')\n\t}\n\n\tfunction fromByteArray (uint8) {\n\t  if (!inited) {\n\t    init();\n\t  }\n\t  var tmp;\n\t  var len = uint8.length;\n\t  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\t  var output = '';\n\t  var parts = [];\n\t  var maxChunkLength = 16383; // must be multiple of 3\n\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n\t  }\n\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1];\n\t    output += lookup[tmp >> 2];\n\t    output += lookup[(tmp << 4) & 0x3F];\n\t    output += '==';\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n\t    output += lookup[tmp >> 10];\n\t    output += lookup[(tmp >> 4) & 0x3F];\n\t    output += lookup[(tmp << 2) & 0x3F];\n\t    output += '=';\n\t  }\n\n\t  parts.push(output);\n\n\t  return parts.join('')\n\t}\n\n\tfunction read (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m;\n\t  var eLen = nBytes * 8 - mLen - 1;\n\t  var eMax = (1 << eLen) - 1;\n\t  var eBias = eMax >> 1;\n\t  var nBits = -7;\n\t  var i = isLE ? (nBytes - 1) : 0;\n\t  var d = isLE ? -1 : 1;\n\t  var s = buffer[offset + i];\n\n\t  i += d;\n\n\t  e = s & ((1 << (-nBits)) - 1);\n\t  s >>= (-nBits);\n\t  nBits += eLen;\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  m = e & ((1 << (-nBits)) - 1);\n\t  e >>= (-nBits);\n\t  nBits += mLen;\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  if (e === 0) {\n\t    e = 1 - eBias;\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen);\n\t    e = e - eBias;\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\n\tfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c;\n\t  var eLen = nBytes * 8 - mLen - 1;\n\t  var eMax = (1 << eLen) - 1;\n\t  var eBias = eMax >> 1;\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n\t  var i = isLE ? 0 : (nBytes - 1);\n\t  var d = isLE ? 1 : -1;\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n\t  value = Math.abs(value);\n\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0;\n\t    e = eMax;\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2);\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--;\n\t      c *= 2;\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c;\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias);\n\t    }\n\t    if (value * c >= 2) {\n\t      e++;\n\t      c /= 2;\n\t    }\n\n\t    if (e + eBias >= eMax) {\n\t      m = 0;\n\t      e = eMax;\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen);\n\t      e = e + eBias;\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n\t      e = 0;\n\t    }\n\t  }\n\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n\t  e = (e << mLen) | m;\n\t  eLen += mLen;\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n\t  buffer[offset + i - d] |= s * 128;\n\t}\n\n\tvar toString = {}.toString;\n\n\tvar isArray$2 = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\t/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\n\n\tvar INSPECT_MAX_BYTES = 50;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global$1.TYPED_ARRAY_SUPPORT\n\t  : true;\n\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\tkMaxLength();\n\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length);\n\t    that.__proto__ = Buffer.prototype;\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length);\n\t    }\n\t    that.length = length;\n\t  }\n\n\t  return that\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192; // not used by this implementation\n\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype;\n\t  return arr\n\t};\n\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\n\t  return fromObject(that, value)\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t};\n\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype;\n\t  Buffer.__proto__ = Uint8Array;\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) ;\n\t}\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size);\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0;\n\t    }\n\t  }\n\t  return that\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t};\n\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\n\t  var length = byteLength(string, encoding) | 0;\n\t  that = createBuffer(that, length);\n\n\t  var actual = that.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual);\n\t  }\n\n\t  return that\n\t}\n\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  that = createBuffer(that, length);\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255;\n\t  }\n\t  return that\n\t}\n\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array);\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset);\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length);\n\t  }\n\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array;\n\t    that.__proto__ = Buffer.prototype;\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array);\n\t  }\n\t  return that\n\t}\n\n\tfunction fromObject (that, obj) {\n\t  if (internalIsBuffer(obj)) {\n\t    var len = checked(obj.length) | 0;\n\t    that = createBuffer(that, len);\n\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\n\t    obj.copy(that, 0, 0, len);\n\t    return that\n\t  }\n\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\n\t    if (obj.type === 'Buffer' && isArray$2(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\tBuffer.isBuffer = isBuffer;\n\tfunction internalIsBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\n\t  if (a === b) return 0\n\n\t  var x = a.length;\n\t  var y = b.length;\n\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray$2(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  var i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  var buffer = Buffer.allocUnsafe(length);\n\t  var pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i];\n\t    if (!internalIsBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos);\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (internalIsBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string;\n\t  }\n\n\t  var len = string.length;\n\t  if (len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  var i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t};\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = '';\n\t  var max = INSPECT_MAX_BYTES;\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n\t    if (this.length > max) str += ' ... ';\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t};\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!internalIsBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  var x = thisEnd - thisStart;\n\t  var y = end - start;\n\t  var len = Math.min(x, y);\n\n\t  var thisCopy = this.slice(thisStart, thisEnd);\n\t  var targetCopy = target.slice(start, end);\n\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000;\n\t  }\n\t  byteOffset = +byteOffset;  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (internalIsBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1;\n\t  var arrLength = arr.length;\n\t  var valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  var i;\n\t  if (dir) {\n\t    var foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true;\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  var remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  // must be an even number of digits\n\t  var strLen = string.length;\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0;\n\t    if (isFinite(length)) {\n\t      length = length | 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  var remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  var loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return fromByteArray(buf)\n\t  } else {\n\t    return fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  var res = [];\n\n\t  var i = start;\n\t  while (i < end) {\n\t    var firstByte = buf[i];\n\t    var codePoint = null;\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = '';\n\t  var i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  var out = '';\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i]);\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end);\n\t  var res = '';\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  var newBuf;\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end);\n\t    newBuf.__proto__ = Buffer.prototype;\n\t  } else {\n\t    var sliceLen = end - start;\n\t    newBuf = new Buffer(sliceLen, undefined);\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start];\n\t    }\n\t  }\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var val = this[offset];\n\t  var mul = 1;\n\t  var i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  var val = this[offset + --byteLength];\n\t  var mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var val = this[offset];\n\t  var mul = 1;\n\t  var i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var i = byteLength;\n\t  var mul = 1;\n\t  var val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  var val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  var val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  var mul = 1;\n\t  var i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  var i = byteLength - 1;\n\t  var mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1;\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8;\n\t  }\n\t}\n\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8);\n\t    this[offset + 1] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false);\n\t  }\n\t  return offset + 2\n\t};\n\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n\t  }\n\t}\n\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24);\n\t    this[offset + 2] = (value >>> 16);\n\t    this[offset + 1] = (value >>> 8);\n\t    this[offset] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24);\n\t    this[offset + 1] = (value >>> 16);\n\t    this[offset + 2] = (value >>> 8);\n\t    this[offset + 3] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  var i = 0;\n\t  var mul = 1;\n\t  var sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  var i = byteLength - 1;\n\t  var mul = 1;\n\t  var sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8);\n\t    this[offset + 1] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t    this[offset + 2] = (value >>> 16);\n\t    this[offset + 3] = (value >>> 24);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24);\n\t    this[offset + 1] = (value >>> 16);\n\t    this[offset + 2] = (value >>> 8);\n\t    this[offset + 3] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false);\n\t  }\n\t  return offset + 4\n\t};\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  var len = end - start;\n\t  var i;\n\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start];\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start];\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0);\n\t      if (code < 256) {\n\t        val = code;\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  var i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    var bytes = internalIsBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString());\n\t    var len = bytes.length;\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  var codePoint;\n\t  var length = string.length;\n\t  var leadSurrogate = null;\n\t  var bytes = [];\n\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  var byteArray = [];\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo;\n\t  var byteArray = [];\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\n\tfunction base64ToBytes (str) {\n\t  return toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\n\n\t// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n\t// The _isBuffer check is for Safari 5-7 support, because it's missing\n\t// Object.prototype.constructor. Remove this eventually\n\tfunction isBuffer(obj) {\n\t  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n\t}\n\n\tfunction isFastBuffer (obj) {\n\t  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n\t}\n\n\t// For Node v0.10 support. Remove this eventually.\n\tfunction isSlowBuffer (obj) {\n\t  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n\t}\n\n\t// shim for using process in browser\n\t// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\tvar cachedSetTimeout = defaultSetTimout;\n\tvar cachedClearTimeout = defaultClearTimeout;\n\tif (typeof global$1.setTimeout === 'function') {\n\t    cachedSetTimeout = setTimeout;\n\t}\n\tif (typeof global$1.clearTimeout === 'function') {\n\t    cachedClearTimeout = clearTimeout;\n\t}\n\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\n\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\n\n\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\tfunction nextTick(fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t}\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tvar title = 'browser';\n\tvar platform = 'browser';\n\tvar browser = true;\n\tvar env = {};\n\tvar argv = [];\n\tvar version = ''; // empty string to avoid regexp issues\n\tvar versions = {};\n\tvar release = {};\n\tvar config = {};\n\n\tfunction noop() {}\n\n\tvar on = noop;\n\tvar addListener = noop;\n\tvar once = noop;\n\tvar off = noop;\n\tvar removeListener = noop;\n\tvar removeAllListeners = noop;\n\tvar emit = noop;\n\n\tfunction binding(name) {\n\t    throw new Error('process.binding is not supported');\n\t}\n\n\tfunction cwd () { return '/' }\n\tfunction chdir (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t}function umask() { return 0; }\n\n\t// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\n\tvar performance = global$1.performance || {};\n\tvar performanceNow =\n\t  performance.now        ||\n\t  performance.mozNow     ||\n\t  performance.msNow      ||\n\t  performance.oNow       ||\n\t  performance.webkitNow  ||\n\t  function(){ return (new Date()).getTime() };\n\n\t// generate timestamp or delta\n\t// see http://nodejs.org/api/process.html#process_process_hrtime\n\tfunction hrtime(previousTimestamp){\n\t  var clocktime = performanceNow.call(performance)*1e-3;\n\t  var seconds = Math.floor(clocktime);\n\t  var nanoseconds = Math.floor((clocktime%1)*1e9);\n\t  if (previousTimestamp) {\n\t    seconds = seconds - previousTimestamp[0];\n\t    nanoseconds = nanoseconds - previousTimestamp[1];\n\t    if (nanoseconds<0) {\n\t      seconds--;\n\t      nanoseconds += 1e9;\n\t    }\n\t  }\n\t  return [seconds,nanoseconds]\n\t}\n\n\tvar startTime = new Date();\n\tfunction uptime() {\n\t  var currentTime = new Date();\n\t  var dif = currentTime - startTime;\n\t  return dif / 1000;\n\t}\n\n\tvar browser$1 = {\n\t  nextTick: nextTick,\n\t  title: title,\n\t  browser: browser,\n\t  env: env,\n\t  argv: argv,\n\t  version: version,\n\t  versions: versions,\n\t  on: on,\n\t  addListener: addListener,\n\t  once: once,\n\t  off: off,\n\t  removeListener: removeListener,\n\t  removeAllListeners: removeAllListeners,\n\t  emit: emit,\n\t  binding: binding,\n\t  cwd: cwd,\n\t  chdir: chdir,\n\t  umask: umask,\n\t  hrtime: hrtime,\n\t  platform: platform,\n\t  release: release,\n\t  config: config,\n\t  uptime: uptime\n\t};\n\n\tvar hasFetch = isFunction$1(global$1.fetch) && isFunction$1(global$1.ReadableStream);\n\n\tvar _blobConstructor;\n\tfunction blobConstructor() {\n\t  if (typeof _blobConstructor !== 'undefined') {\n\t    return _blobConstructor;\n\t  }\n\t  try {\n\t    new global$1.Blob([new ArrayBuffer(1)]);\n\t    _blobConstructor = true;\n\t  } catch (e) {\n\t    _blobConstructor = false;\n\t  }\n\t  return _blobConstructor\n\t}\n\tvar xhr;\n\n\tfunction checkTypeSupport(type) {\n\t  if (!xhr) {\n\t    xhr = new global$1.XMLHttpRequest();\n\t    // If location.host is empty, e.g. if this page/worker was loaded\n\t    // from a Blob, then use example.com to avoid an error\n\t    xhr.open('GET', global$1.location.host ? '/' : 'https://example.com');\n\t  }\n\t  try {\n\t    xhr.responseType = type;\n\t    return xhr.responseType === type\n\t  } catch (e) {\n\t    return false\n\t  }\n\n\t}\n\n\t// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n\t// Safari 7.1 appears to have fixed this bug.\n\tvar haveArrayBuffer = typeof global$1.ArrayBuffer !== 'undefined';\n\tvar haveSlice = haveArrayBuffer && isFunction$1(global$1.ArrayBuffer.prototype.slice);\n\n\tvar arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer');\n\t  // These next two tests unavoidably show warnings in Chrome. Since fetch will always\n\t  // be used if it's available, just return false for these to avoid the warnings.\n\tvar msstream = !hasFetch && haveSlice && checkTypeSupport('ms-stream');\n\tvar mozchunkedarraybuffer = !hasFetch && haveArrayBuffer &&\n\t  checkTypeSupport('moz-chunked-arraybuffer');\n\tvar overrideMimeType = isFunction$1(xhr.overrideMimeType);\n\tvar vbArray = isFunction$1(global$1.VBArray);\n\n\tfunction isFunction$1(value) {\n\t  return typeof value === 'function'\n\t}\n\n\txhr = null; // Help gc\n\n\tvar inherits;\n\tif (typeof Object.create === 'function'){\n\t  inherits = function inherits(ctor, superCtor) {\n\t    // implementation from standard node.js 'util' module\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  inherits = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  };\n\t}\n\n\tvar formatRegExp = /%[sdj%]/g;\n\tfunction format$1(f) {\n\t  if (!isString(f)) {\n\t    var objects = [];\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      objects.push(inspect(arguments[i]));\n\t    }\n\t    return objects.join(' ');\n\t  }\n\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function(x) {\n\t    if (x === '%%') return '%';\n\t    if (i >= len) return x;\n\t    switch (x) {\n\t      case '%s': return String(args[i++]);\n\t      case '%d': return Number(args[i++]);\n\t      case '%j':\n\t        try {\n\t          return JSON.stringify(args[i++]);\n\t        } catch (_) {\n\t          return '[Circular]';\n\t        }\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  for (var x = args[i]; i < len; x = args[++i]) {\n\t    if (isNull(x) || !isObject(x)) {\n\t      str += ' ' + x;\n\t    } else {\n\t      str += ' ' + inspect(x);\n\t    }\n\t  }\n\t  return str;\n\t}\n\n\t// Mark that a method should not be used.\n\t// Returns a modified function which warns once by default.\n\t// If --no-deprecation is set, then it is a no-op.\n\tfunction deprecate(fn, msg) {\n\t  // Allow for deprecating things in the process of starting up.\n\t  if (isUndefined(global$1.process)) {\n\t    return function() {\n\t      return deprecate(fn, msg).apply(this, arguments);\n\t    };\n\t  }\n\n\t  if (browser$1.noDeprecation === true) {\n\t    return fn;\n\t  }\n\n\t  var warned = false;\n\t  function deprecated() {\n\t    if (!warned) {\n\t      if (browser$1.throwDeprecation) {\n\t        throw new Error(msg);\n\t      } else if (browser$1.traceDeprecation) {\n\t        console.trace(msg);\n\t      } else {\n\t        console.error(msg);\n\t      }\n\t      warned = true;\n\t    }\n\t    return fn.apply(this, arguments);\n\t  }\n\n\t  return deprecated;\n\t}\n\n\tvar debugs = {};\n\tvar debugEnviron;\n\tfunction debuglog(set) {\n\t  if (isUndefined(debugEnviron))\n\t    debugEnviron = browser$1.env.NODE_DEBUG || '';\n\t  set = set.toUpperCase();\n\t  if (!debugs[set]) {\n\t    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n\t      var pid = 0;\n\t      debugs[set] = function() {\n\t        var msg = format$1.apply(null, arguments);\n\t        console.error('%s %d: %s', set, pid, msg);\n\t      };\n\t    } else {\n\t      debugs[set] = function() {};\n\t    }\n\t  }\n\t  return debugs[set];\n\t}\n\n\t/**\n\t * Echos the value of a value. Trys to print the value out\n\t * in the best way possible given the different types.\n\t *\n\t * @param {Object} obj The object to print out.\n\t * @param {Object} opts Optional options object that alters the output.\n\t */\n\t/* legacy: obj, showHidden, depth, colors*/\n\tfunction inspect(obj, opts) {\n\t  // default options\n\t  var ctx = {\n\t    seen: [],\n\t    stylize: stylizeNoColor\n\t  };\n\t  // legacy...\n\t  if (arguments.length >= 3) ctx.depth = arguments[2];\n\t  if (arguments.length >= 4) ctx.colors = arguments[3];\n\t  if (isBoolean(opts)) {\n\t    // legacy...\n\t    ctx.showHidden = opts;\n\t  } else if (opts) {\n\t    // got an \"options\" object\n\t    _extend(ctx, opts);\n\t  }\n\t  // set default options\n\t  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n\t  if (isUndefined(ctx.depth)) ctx.depth = 2;\n\t  if (isUndefined(ctx.colors)) ctx.colors = false;\n\t  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n\t  if (ctx.colors) ctx.stylize = stylizeWithColor;\n\t  return formatValue(ctx, obj, ctx.depth);\n\t}\n\n\t// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\tinspect.colors = {\n\t  'bold' : [1, 22],\n\t  'italic' : [3, 23],\n\t  'underline' : [4, 24],\n\t  'inverse' : [7, 27],\n\t  'white' : [37, 39],\n\t  'grey' : [90, 39],\n\t  'black' : [30, 39],\n\t  'blue' : [34, 39],\n\t  'cyan' : [36, 39],\n\t  'green' : [32, 39],\n\t  'magenta' : [35, 39],\n\t  'red' : [31, 39],\n\t  'yellow' : [33, 39]\n\t};\n\n\t// Don't use 'blue' not visible on cmd.exe\n\tinspect.styles = {\n\t  'special': 'cyan',\n\t  'number': 'yellow',\n\t  'boolean': 'yellow',\n\t  'undefined': 'grey',\n\t  'null': 'bold',\n\t  'string': 'green',\n\t  'date': 'magenta',\n\t  // \"name\": intentionally not styling\n\t  'regexp': 'red'\n\t};\n\n\n\tfunction stylizeWithColor(str, styleType) {\n\t  var style = inspect.styles[styleType];\n\n\t  if (style) {\n\t    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n\t           '\\u001b[' + inspect.colors[style][1] + 'm';\n\t  } else {\n\t    return str;\n\t  }\n\t}\n\n\n\tfunction stylizeNoColor(str, styleType) {\n\t  return str;\n\t}\n\n\n\tfunction arrayToHash(array) {\n\t  var hash = {};\n\n\t  array.forEach(function(val, idx) {\n\t    hash[val] = true;\n\t  });\n\n\t  return hash;\n\t}\n\n\n\tfunction formatValue(ctx, value, recurseTimes) {\n\t  // Provide a hook for user-specified inspect functions.\n\t  // Check that value is an object with an inspect function on it\n\t  if (ctx.customInspect &&\n\t      value &&\n\t      isFunction(value.inspect) &&\n\t      // Filter out the util module, it's inspect function is special\n\t      value.inspect !== inspect &&\n\t      // Also filter out any prototype objects using the circular check.\n\t      !(value.constructor && value.constructor.prototype === value)) {\n\t    var ret = value.inspect(recurseTimes, ctx);\n\t    if (!isString(ret)) {\n\t      ret = formatValue(ctx, ret, recurseTimes);\n\t    }\n\t    return ret;\n\t  }\n\n\t  // Primitive types cannot have properties\n\t  var primitive = formatPrimitive(ctx, value);\n\t  if (primitive) {\n\t    return primitive;\n\t  }\n\n\t  // Look up the keys of the object.\n\t  var keys = Object.keys(value);\n\t  var visibleKeys = arrayToHash(keys);\n\n\t  if (ctx.showHidden) {\n\t    keys = Object.getOwnPropertyNames(value);\n\t  }\n\n\t  // IE doesn't make error fields non-enumerable\n\t  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\t  if (isError(value)\n\t      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n\t    return formatError(value);\n\t  }\n\n\t  // Some type of object without properties can be shortcutted.\n\t  if (keys.length === 0) {\n\t    if (isFunction(value)) {\n\t      var name = value.name ? ': ' + value.name : '';\n\t      return ctx.stylize('[Function' + name + ']', 'special');\n\t    }\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    }\n\t    if (isDate(value)) {\n\t      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n\t    }\n\t    if (isError(value)) {\n\t      return formatError(value);\n\t    }\n\t  }\n\n\t  var base = '', array = false, braces = ['{', '}'];\n\n\t  // Make Array say that they are Array\n\t  if (isArray$1(value)) {\n\t    array = true;\n\t    braces = ['[', ']'];\n\t  }\n\n\t  // Make functions say that they are functions\n\t  if (isFunction(value)) {\n\t    var n = value.name ? ': ' + value.name : '';\n\t    base = ' [Function' + n + ']';\n\t  }\n\n\t  // Make RegExps say that they are RegExps\n\t  if (isRegExp(value)) {\n\t    base = ' ' + RegExp.prototype.toString.call(value);\n\t  }\n\n\t  // Make dates with properties first say the date\n\t  if (isDate(value)) {\n\t    base = ' ' + Date.prototype.toUTCString.call(value);\n\t  }\n\n\t  // Make error with message first say the error\n\t  if (isError(value)) {\n\t    base = ' ' + formatError(value);\n\t  }\n\n\t  if (keys.length === 0 && (!array || value.length == 0)) {\n\t    return braces[0] + base + braces[1];\n\t  }\n\n\t  if (recurseTimes < 0) {\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    } else {\n\t      return ctx.stylize('[Object]', 'special');\n\t    }\n\t  }\n\n\t  ctx.seen.push(value);\n\n\t  var output;\n\t  if (array) {\n\t    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n\t  } else {\n\t    output = keys.map(function(key) {\n\t      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n\t    });\n\t  }\n\n\t  ctx.seen.pop();\n\n\t  return reduceToSingleString(output, base, braces);\n\t}\n\n\n\tfunction formatPrimitive(ctx, value) {\n\t  if (isUndefined(value))\n\t    return ctx.stylize('undefined', 'undefined');\n\t  if (isString(value)) {\n\t    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n\t                                             .replace(/'/g, \"\\\\'\")\n\t                                             .replace(/\\\\\"/g, '\"') + '\\'';\n\t    return ctx.stylize(simple, 'string');\n\t  }\n\t  if (isNumber(value))\n\t    return ctx.stylize('' + value, 'number');\n\t  if (isBoolean(value))\n\t    return ctx.stylize('' + value, 'boolean');\n\t  // For some reason typeof null is \"object\", so special case here.\n\t  if (isNull(value))\n\t    return ctx.stylize('null', 'null');\n\t}\n\n\n\tfunction formatError(value) {\n\t  return '[' + Error.prototype.toString.call(value) + ']';\n\t}\n\n\n\tfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n\t  var output = [];\n\t  for (var i = 0, l = value.length; i < l; ++i) {\n\t    if (hasOwnProperty$1(value, String(i))) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          String(i), true));\n\t    } else {\n\t      output.push('');\n\t    }\n\t  }\n\t  keys.forEach(function(key) {\n\t    if (!key.match(/^\\d+$/)) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          key, true));\n\t    }\n\t  });\n\t  return output;\n\t}\n\n\n\tfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n\t  var name, str, desc;\n\t  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n\t  if (desc.get) {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Getter/Setter]', 'special');\n\t    } else {\n\t      str = ctx.stylize('[Getter]', 'special');\n\t    }\n\t  } else {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Setter]', 'special');\n\t    }\n\t  }\n\t  if (!hasOwnProperty$1(visibleKeys, key)) {\n\t    name = '[' + key + ']';\n\t  }\n\t  if (!str) {\n\t    if (ctx.seen.indexOf(desc.value) < 0) {\n\t      if (isNull(recurseTimes)) {\n\t        str = formatValue(ctx, desc.value, null);\n\t      } else {\n\t        str = formatValue(ctx, desc.value, recurseTimes - 1);\n\t      }\n\t      if (str.indexOf('\\n') > -1) {\n\t        if (array) {\n\t          str = str.split('\\n').map(function(line) {\n\t            return '  ' + line;\n\t          }).join('\\n').substr(2);\n\t        } else {\n\t          str = '\\n' + str.split('\\n').map(function(line) {\n\t            return '   ' + line;\n\t          }).join('\\n');\n\t        }\n\t      }\n\t    } else {\n\t      str = ctx.stylize('[Circular]', 'special');\n\t    }\n\t  }\n\t  if (isUndefined(name)) {\n\t    if (array && key.match(/^\\d+$/)) {\n\t      return str;\n\t    }\n\t    name = JSON.stringify('' + key);\n\t    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n\t      name = name.substr(1, name.length - 2);\n\t      name = ctx.stylize(name, 'name');\n\t    } else {\n\t      name = name.replace(/'/g, \"\\\\'\")\n\t                 .replace(/\\\\\"/g, '\"')\n\t                 .replace(/(^\"|\"$)/g, \"'\");\n\t      name = ctx.stylize(name, 'string');\n\t    }\n\t  }\n\n\t  return name + ': ' + str;\n\t}\n\n\n\tfunction reduceToSingleString(output, base, braces) {\n\t  var length = output.reduce(function(prev, cur) {\n\t    if (cur.indexOf('\\n') >= 0) ;\n\t    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n\t  }, 0);\n\n\t  if (length > 60) {\n\t    return braces[0] +\n\t           (base === '' ? '' : base + '\\n ') +\n\t           ' ' +\n\t           output.join(',\\n  ') +\n\t           ' ' +\n\t           braces[1];\n\t  }\n\n\t  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n\t}\n\n\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\tfunction isArray$1(ar) {\n\t  return Array.isArray(ar);\n\t}\n\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\tfunction isRegExp(re) {\n\t  return isObject(re) && objectToString(re) === '[object RegExp]';\n\t}\n\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\n\tfunction isDate(d) {\n\t  return isObject(d) && objectToString(d) === '[object Date]';\n\t}\n\n\tfunction isError(e) {\n\t  return isObject(e) &&\n\t      (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\n\tfunction _extend(origin, add) {\n\t  // Don't do anything if add isn't an object\n\t  if (!add || !isObject(add)) return origin;\n\n\t  var keys = Object.keys(add);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    origin[keys[i]] = add[keys[i]];\n\t  }\n\t  return origin;\n\t}\n\tfunction hasOwnProperty$1(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\n\tvar domain;\n\n\t// This constructor is used to store event handlers. Instantiating this is\n\t// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n\t// object (tested with v8 v4.9).\n\tfunction EventHandlers() {}\n\tEventHandlers.prototype = Object.create(null);\n\n\tfunction EventEmitter() {\n\t  EventEmitter.init.call(this);\n\t}\n\n\t// nodejs oddity\n\t// require('events') === require('events').EventEmitter\n\tEventEmitter.EventEmitter = EventEmitter;\n\n\tEventEmitter.usingDomains = false;\n\n\tEventEmitter.prototype.domain = undefined;\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\n\tEventEmitter.init = function() {\n\t  this.domain = null;\n\t  if (EventEmitter.usingDomains) {\n\t    // if there is an active domain, then attach to it.\n\t    if (domain.active) ;\n\t  }\n\n\t  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n\t    this._events = new EventHandlers();\n\t    this._eventsCount = 0;\n\t  }\n\n\t  this._maxListeners = this._maxListeners || undefined;\n\t};\n\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n\t  if (typeof n !== 'number' || n < 0 || isNaN(n))\n\t    throw new TypeError('\"n\" argument must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\n\tfunction $getMaxListeners(that) {\n\t  if (that._maxListeners === undefined)\n\t    return EventEmitter.defaultMaxListeners;\n\t  return that._maxListeners;\n\t}\n\n\tEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n\t  return $getMaxListeners(this);\n\t};\n\n\t// These standalone emit* functions are used to optimize calling of event\n\t// handlers for fast cases because emit() itself often has a variable number of\n\t// arguments and can be deoptimized because of that. These functions always have\n\t// the same number of arguments and thus do not get deoptimized, so the code\n\t// inside them can execute faster.\n\tfunction emitNone(handler, isFn, self) {\n\t  if (isFn)\n\t    handler.call(self);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self);\n\t  }\n\t}\n\tfunction emitOne(handler, isFn, self, arg1) {\n\t  if (isFn)\n\t    handler.call(self, arg1);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self, arg1);\n\t  }\n\t}\n\tfunction emitTwo(handler, isFn, self, arg1, arg2) {\n\t  if (isFn)\n\t    handler.call(self, arg1, arg2);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self, arg1, arg2);\n\t  }\n\t}\n\tfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n\t  if (isFn)\n\t    handler.call(self, arg1, arg2, arg3);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self, arg1, arg2, arg3);\n\t  }\n\t}\n\n\tfunction emitMany(handler, isFn, self, args) {\n\t  if (isFn)\n\t    handler.apply(self, args);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].apply(self, args);\n\t  }\n\t}\n\n\tEventEmitter.prototype.emit = function emit(type) {\n\t  var er, handler, len, args, i, events, domain;\n\t  var doError = (type === 'error');\n\n\t  events = this._events;\n\t  if (events)\n\t    doError = (doError && events.error == null);\n\t  else if (!doError)\n\t    return false;\n\n\t  domain = this.domain;\n\n\t  // If there is no 'error' event listener then throw.\n\t  if (doError) {\n\t    er = arguments[1];\n\t    if (domain) {\n\t      if (!er)\n\t        er = new Error('Uncaught, unspecified \"error\" event');\n\t      er.domainEmitter = this;\n\t      er.domain = domain;\n\t      er.domainThrown = false;\n\t      domain.emit('error', er);\n\t    } else if (er instanceof Error) {\n\t      throw er; // Unhandled 'error' event\n\t    } else {\n\t      // At least give some kind of context to the user\n\t      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t      err.context = er;\n\t      throw err;\n\t    }\n\t    return false;\n\t  }\n\n\t  handler = events[type];\n\n\t  if (!handler)\n\t    return false;\n\n\t  var isFn = typeof handler === 'function';\n\t  len = arguments.length;\n\t  switch (len) {\n\t    // fast cases\n\t    case 1:\n\t      emitNone(handler, isFn, this);\n\t      break;\n\t    case 2:\n\t      emitOne(handler, isFn, this, arguments[1]);\n\t      break;\n\t    case 3:\n\t      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n\t      break;\n\t    case 4:\n\t      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n\t      break;\n\t    // slower\n\t    default:\n\t      args = new Array(len - 1);\n\t      for (i = 1; i < len; i++)\n\t        args[i - 1] = arguments[i];\n\t      emitMany(handler, isFn, this, args);\n\t  }\n\n\t  return true;\n\t};\n\n\tfunction _addListener(target, type, listener, prepend) {\n\t  var m;\n\t  var events;\n\t  var existing;\n\n\t  if (typeof listener !== 'function')\n\t    throw new TypeError('\"listener\" argument must be a function');\n\n\t  events = target._events;\n\t  if (!events) {\n\t    events = target._events = new EventHandlers();\n\t    target._eventsCount = 0;\n\t  } else {\n\t    // To avoid recursion in the case that type === \"newListener\"! Before\n\t    // adding it to the listeners, first emit \"newListener\".\n\t    if (events.newListener) {\n\t      target.emit('newListener', type,\n\t                  listener.listener ? listener.listener : listener);\n\n\t      // Re-assign `events` because a newListener handler could have caused the\n\t      // this._events to be assigned to a new object\n\t      events = target._events;\n\t    }\n\t    existing = events[type];\n\t  }\n\n\t  if (!existing) {\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    existing = events[type] = listener;\n\t    ++target._eventsCount;\n\t  } else {\n\t    if (typeof existing === 'function') {\n\t      // Adding the second element, need to change to array.\n\t      existing = events[type] = prepend ? [listener, existing] :\n\t                                          [existing, listener];\n\t    } else {\n\t      // If we've already got an array, just append.\n\t      if (prepend) {\n\t        existing.unshift(listener);\n\t      } else {\n\t        existing.push(listener);\n\t      }\n\t    }\n\n\t    // Check for listener leak\n\t    if (!existing.warned) {\n\t      m = $getMaxListeners(target);\n\t      if (m && m > 0 && existing.length > m) {\n\t        existing.warned = true;\n\t        var w = new Error('Possible EventEmitter memory leak detected. ' +\n\t                            existing.length + ' ' + type + ' listeners added. ' +\n\t                            'Use emitter.setMaxListeners() to increase limit');\n\t        w.name = 'MaxListenersExceededWarning';\n\t        w.emitter = target;\n\t        w.type = type;\n\t        w.count = existing.length;\n\t        emitWarning(w);\n\t      }\n\t    }\n\t  }\n\n\t  return target;\n\t}\n\tfunction emitWarning(e) {\n\t  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n\t}\n\tEventEmitter.prototype.addListener = function addListener(type, listener) {\n\t  return _addListener(this, type, listener, false);\n\t};\n\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n\tEventEmitter.prototype.prependListener =\n\t    function prependListener(type, listener) {\n\t      return _addListener(this, type, listener, true);\n\t    };\n\n\tfunction _onceWrap(target, type, listener) {\n\t  var fired = false;\n\t  function g() {\n\t    target.removeListener(type, g);\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(target, arguments);\n\t    }\n\t  }\n\t  g.listener = listener;\n\t  return g;\n\t}\n\n\tEventEmitter.prototype.once = function once(type, listener) {\n\t  if (typeof listener !== 'function')\n\t    throw new TypeError('\"listener\" argument must be a function');\n\t  this.on(type, _onceWrap(this, type, listener));\n\t  return this;\n\t};\n\n\tEventEmitter.prototype.prependOnceListener =\n\t    function prependOnceListener(type, listener) {\n\t      if (typeof listener !== 'function')\n\t        throw new TypeError('\"listener\" argument must be a function');\n\t      this.prependListener(type, _onceWrap(this, type, listener));\n\t      return this;\n\t    };\n\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener =\n\t    function removeListener(type, listener) {\n\t      var list, events, position, i, originalListener;\n\n\t      if (typeof listener !== 'function')\n\t        throw new TypeError('\"listener\" argument must be a function');\n\n\t      events = this._events;\n\t      if (!events)\n\t        return this;\n\n\t      list = events[type];\n\t      if (!list)\n\t        return this;\n\n\t      if (list === listener || (list.listener && list.listener === listener)) {\n\t        if (--this._eventsCount === 0)\n\t          this._events = new EventHandlers();\n\t        else {\n\t          delete events[type];\n\t          if (events.removeListener)\n\t            this.emit('removeListener', type, list.listener || listener);\n\t        }\n\t      } else if (typeof list !== 'function') {\n\t        position = -1;\n\n\t        for (i = list.length; i-- > 0;) {\n\t          if (list[i] === listener ||\n\t              (list[i].listener && list[i].listener === listener)) {\n\t            originalListener = list[i].listener;\n\t            position = i;\n\t            break;\n\t          }\n\t        }\n\n\t        if (position < 0)\n\t          return this;\n\n\t        if (list.length === 1) {\n\t          list[0] = undefined;\n\t          if (--this._eventsCount === 0) {\n\t            this._events = new EventHandlers();\n\t            return this;\n\t          } else {\n\t            delete events[type];\n\t          }\n\t        } else {\n\t          spliceOne(list, position);\n\t        }\n\n\t        if (events.removeListener)\n\t          this.emit('removeListener', type, originalListener || listener);\n\t      }\n\n\t      return this;\n\t    };\n\t    \n\t// Alias for removeListener added in NodeJS 10.0\n\t// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\n\tEventEmitter.prototype.off = function(type, listener){\n\t    return this.removeListener(type, listener);\n\t};\n\n\tEventEmitter.prototype.removeAllListeners =\n\t    function removeAllListeners(type) {\n\t      var listeners, events;\n\n\t      events = this._events;\n\t      if (!events)\n\t        return this;\n\n\t      // not listening for removeListener, no need to emit\n\t      if (!events.removeListener) {\n\t        if (arguments.length === 0) {\n\t          this._events = new EventHandlers();\n\t          this._eventsCount = 0;\n\t        } else if (events[type]) {\n\t          if (--this._eventsCount === 0)\n\t            this._events = new EventHandlers();\n\t          else\n\t            delete events[type];\n\t        }\n\t        return this;\n\t      }\n\n\t      // emit removeListener for all listeners on all events\n\t      if (arguments.length === 0) {\n\t        var keys = Object.keys(events);\n\t        for (var i = 0, key; i < keys.length; ++i) {\n\t          key = keys[i];\n\t          if (key === 'removeListener') continue;\n\t          this.removeAllListeners(key);\n\t        }\n\t        this.removeAllListeners('removeListener');\n\t        this._events = new EventHandlers();\n\t        this._eventsCount = 0;\n\t        return this;\n\t      }\n\n\t      listeners = events[type];\n\n\t      if (typeof listeners === 'function') {\n\t        this.removeListener(type, listeners);\n\t      } else if (listeners) {\n\t        // LIFO order\n\t        do {\n\t          this.removeListener(type, listeners[listeners.length - 1]);\n\t        } while (listeners[0]);\n\t      }\n\n\t      return this;\n\t    };\n\n\tEventEmitter.prototype.listeners = function listeners(type) {\n\t  var evlistener;\n\t  var ret;\n\t  var events = this._events;\n\n\t  if (!events)\n\t    ret = [];\n\t  else {\n\t    evlistener = events[type];\n\t    if (!evlistener)\n\t      ret = [];\n\t    else if (typeof evlistener === 'function')\n\t      ret = [evlistener.listener || evlistener];\n\t    else\n\t      ret = unwrapListeners(evlistener);\n\t  }\n\n\t  return ret;\n\t};\n\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  if (typeof emitter.listenerCount === 'function') {\n\t    return emitter.listenerCount(type);\n\t  } else {\n\t    return listenerCount$1.call(emitter, type);\n\t  }\n\t};\n\n\tEventEmitter.prototype.listenerCount = listenerCount$1;\n\tfunction listenerCount$1(type) {\n\t  var events = this._events;\n\n\t  if (events) {\n\t    var evlistener = events[type];\n\n\t    if (typeof evlistener === 'function') {\n\t      return 1;\n\t    } else if (evlistener) {\n\t      return evlistener.length;\n\t    }\n\t  }\n\n\t  return 0;\n\t}\n\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n\t};\n\n\t// About 1.5x faster than the two-arg version of Array#splice().\n\tfunction spliceOne(list, index) {\n\t  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n\t    list[i] = list[k];\n\t  list.pop();\n\t}\n\n\tfunction arrayClone(arr, i) {\n\t  var copy = new Array(i);\n\t  while (i--)\n\t    copy[i] = arr[i];\n\t  return copy;\n\t}\n\n\tfunction unwrapListeners(arr) {\n\t  var ret = new Array(arr.length);\n\t  for (var i = 0; i < ret.length; ++i) {\n\t    ret[i] = arr[i].listener || arr[i];\n\t  }\n\t  return ret;\n\t}\n\n\tfunction BufferList() {\n\t  this.head = null;\n\t  this.tail = null;\n\t  this.length = 0;\n\t}\n\n\tBufferList.prototype.push = function (v) {\n\t  var entry = { data: v, next: null };\n\t  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n\t  this.tail = entry;\n\t  ++this.length;\n\t};\n\n\tBufferList.prototype.unshift = function (v) {\n\t  var entry = { data: v, next: this.head };\n\t  if (this.length === 0) this.tail = entry;\n\t  this.head = entry;\n\t  ++this.length;\n\t};\n\n\tBufferList.prototype.shift = function () {\n\t  if (this.length === 0) return;\n\t  var ret = this.head.data;\n\t  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n\t  --this.length;\n\t  return ret;\n\t};\n\n\tBufferList.prototype.clear = function () {\n\t  this.head = this.tail = null;\n\t  this.length = 0;\n\t};\n\n\tBufferList.prototype.join = function (s) {\n\t  if (this.length === 0) return '';\n\t  var p = this.head;\n\t  var ret = '' + p.data;\n\t  while (p = p.next) {\n\t    ret += s + p.data;\n\t  }return ret;\n\t};\n\n\tBufferList.prototype.concat = function (n) {\n\t  if (this.length === 0) return Buffer.alloc(0);\n\t  if (this.length === 1) return this.head.data;\n\t  var ret = Buffer.allocUnsafe(n >>> 0);\n\t  var p = this.head;\n\t  var i = 0;\n\t  while (p) {\n\t    p.data.copy(ret, i);\n\t    i += p.data.length;\n\t    p = p.next;\n\t  }\n\t  return ret;\n\t};\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\tvar isBufferEncoding = Buffer.isEncoding\n\t  || function(encoding) {\n\t       switch (encoding && encoding.toLowerCase()) {\n\t         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n\t         default: return false;\n\t       }\n\t     };\n\n\n\tfunction assertEncoding(encoding) {\n\t  if (encoding && !isBufferEncoding(encoding)) {\n\t    throw new Error('Unknown encoding: ' + encoding);\n\t  }\n\t}\n\n\t// StringDecoder provides an interface for efficiently splitting a series of\n\t// buffers into a series of JS strings without breaking apart multi-byte\n\t// characters. CESU-8 is handled as part of the UTF-8 encoding.\n\t//\n\t// @TODO Handling all encodings inside a single object makes it very difficult\n\t// to reason about this code, so it should be split up in the future.\n\t// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n\t// points as used by CESU-8.\n\tfunction StringDecoder(encoding) {\n\t  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n\t  assertEncoding(encoding);\n\t  switch (this.encoding) {\n\t    case 'utf8':\n\t      // CESU-8 represents each of Surrogate Pair by 3-bytes\n\t      this.surrogateSize = 3;\n\t      break;\n\t    case 'ucs2':\n\t    case 'utf16le':\n\t      // UTF-16 represents each of Surrogate Pair by 2-bytes\n\t      this.surrogateSize = 2;\n\t      this.detectIncompleteChar = utf16DetectIncompleteChar;\n\t      break;\n\t    case 'base64':\n\t      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n\t      this.surrogateSize = 3;\n\t      this.detectIncompleteChar = base64DetectIncompleteChar;\n\t      break;\n\t    default:\n\t      this.write = passThroughWrite;\n\t      return;\n\t  }\n\n\t  // Enough space to store all bytes of a single character. UTF-8 needs 4\n\t  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n\t  this.charBuffer = new Buffer(6);\n\t  // Number of bytes received for the current incomplete multi-byte character.\n\t  this.charReceived = 0;\n\t  // Number of bytes expected for the current incomplete multi-byte character.\n\t  this.charLength = 0;\n\t}\n\n\t// write decodes the given buffer and returns it as JS string that is\n\t// guaranteed to not contain any partial multi-byte characters. Any partial\n\t// character found at the end of the buffer is buffered up, and will be\n\t// returned when calling write again with the remaining bytes.\n\t//\n\t// Note: Converting a Buffer containing an orphan surrogate to a String\n\t// currently works, but converting a String to a Buffer (via `new Buffer`, or\n\t// Buffer#write) will replace incomplete surrogates with the unicode\n\t// replacement character. See https://codereview.chromium.org/121173009/ .\n\tStringDecoder.prototype.write = function(buffer) {\n\t  var charStr = '';\n\t  // if our last write ended with an incomplete multibyte character\n\t  while (this.charLength) {\n\t    // determine how many remaining bytes this buffer has to offer for this char\n\t    var available = (buffer.length >= this.charLength - this.charReceived) ?\n\t        this.charLength - this.charReceived :\n\t        buffer.length;\n\n\t    // add the new bytes to the char buffer\n\t    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n\t    this.charReceived += available;\n\n\t    if (this.charReceived < this.charLength) {\n\t      // still not enough chars in this buffer? wait for more ...\n\t      return '';\n\t    }\n\n\t    // remove bytes belonging to the current character from the buffer\n\t    buffer = buffer.slice(available, buffer.length);\n\n\t    // get the character that was split\n\t    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n\t    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t    var charCode = charStr.charCodeAt(charStr.length - 1);\n\t    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t      this.charLength += this.surrogateSize;\n\t      charStr = '';\n\t      continue;\n\t    }\n\t    this.charReceived = this.charLength = 0;\n\n\t    // if there are no more bytes in this buffer, just emit our char\n\t    if (buffer.length === 0) {\n\t      return charStr;\n\t    }\n\t    break;\n\t  }\n\n\t  // determine and set charLength / charReceived\n\t  this.detectIncompleteChar(buffer);\n\n\t  var end = buffer.length;\n\t  if (this.charLength) {\n\t    // buffer the incomplete character bytes we got\n\t    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n\t    end -= this.charReceived;\n\t  }\n\n\t  charStr += buffer.toString(this.encoding, 0, end);\n\n\t  var end = charStr.length - 1;\n\t  var charCode = charStr.charCodeAt(end);\n\t  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t    var size = this.surrogateSize;\n\t    this.charLength += size;\n\t    this.charReceived += size;\n\t    this.charBuffer.copy(this.charBuffer, size, 0, size);\n\t    buffer.copy(this.charBuffer, 0, 0, size);\n\t    return charStr.substring(0, end);\n\t  }\n\n\t  // or just emit the charStr\n\t  return charStr;\n\t};\n\n\t// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n\t// the end of the given buffer. If so, it sets this.charLength to the byte\n\t// length that character, and sets this.charReceived to the number of bytes\n\t// that are available for this character.\n\tStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n\t  // determine how many bytes we have to check at the end of this buffer\n\t  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n\t  // Figure out if one of the last i bytes of our buffer announces an\n\t  // incomplete char.\n\t  for (; i > 0; i--) {\n\t    var c = buffer[buffer.length - i];\n\n\t    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n\t    // 110XXXXX\n\t    if (i == 1 && c >> 5 == 0x06) {\n\t      this.charLength = 2;\n\t      break;\n\t    }\n\n\t    // 1110XXXX\n\t    if (i <= 2 && c >> 4 == 0x0E) {\n\t      this.charLength = 3;\n\t      break;\n\t    }\n\n\t    // 11110XXX\n\t    if (i <= 3 && c >> 3 == 0x1E) {\n\t      this.charLength = 4;\n\t      break;\n\t    }\n\t  }\n\t  this.charReceived = i;\n\t};\n\n\tStringDecoder.prototype.end = function(buffer) {\n\t  var res = '';\n\t  if (buffer && buffer.length)\n\t    res = this.write(buffer);\n\n\t  if (this.charReceived) {\n\t    var cr = this.charReceived;\n\t    var buf = this.charBuffer;\n\t    var enc = this.encoding;\n\t    res += buf.slice(0, cr).toString(enc);\n\t  }\n\n\t  return res;\n\t};\n\n\tfunction passThroughWrite(buffer) {\n\t  return buffer.toString(this.encoding);\n\t}\n\n\tfunction utf16DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 2;\n\t  this.charLength = this.charReceived ? 2 : 0;\n\t}\n\n\tfunction base64DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 3;\n\t  this.charLength = this.charReceived ? 3 : 0;\n\t}\n\n\tReadable.ReadableState = ReadableState;\n\n\tvar debug = debuglog('stream');\n\tinherits(Readable, EventEmitter);\n\n\tfunction prependListener(emitter, event, fn) {\n\t  // Sadly this is not cacheable as some libraries bundle their own\n\t  // event emitter implementation with them.\n\t  if (typeof emitter.prependListener === 'function') {\n\t    return emitter.prependListener(event, fn);\n\t  } else {\n\t    // This is a hack to make sure that our error handler is attached before any\n\t    // userland ones.  NEVER DO THIS. This is here only because this code needs\n\t    // to continue to work with older versions of Node.js that do not include\n\t    // the prependListener() method. The goal is to eventually remove this hack.\n\t    if (!emitter._events || !emitter._events[event])\n\t      emitter.on(event, fn);\n\t    else if (Array.isArray(emitter._events[event]))\n\t      emitter._events[event].unshift(fn);\n\t    else\n\t      emitter._events[event] = [fn, emitter._events[event]];\n\t  }\n\t}\n\tfunction listenerCount (emitter, type) {\n\t  return emitter.listeners(type).length;\n\t}\n\tfunction ReadableState(options, stream) {\n\n\t  options = options || {};\n\n\t  // object stream flag. Used to make read(n) ignore n and to\n\t  // make all the buffer merging and length checks go away\n\t  this.objectMode = !!options.objectMode;\n\n\t  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n\t  // the point at which it stops calling _read() to fill the buffer\n\t  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n\t  // cast to ints.\n\t  this.highWaterMark = ~ ~this.highWaterMark;\n\n\t  // A linked list is used to store data chunks instead of an array because the\n\t  // linked list can remove elements from the beginning faster than\n\t  // array.shift()\n\t  this.buffer = new BufferList();\n\t  this.length = 0;\n\t  this.pipes = null;\n\t  this.pipesCount = 0;\n\t  this.flowing = null;\n\t  this.ended = false;\n\t  this.endEmitted = false;\n\t  this.reading = false;\n\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\n\t  // whenever we return null, then we set a flag to say\n\t  // that we're awaiting a 'readable' event emission.\n\t  this.needReadable = false;\n\t  this.emittedReadable = false;\n\t  this.readableListening = false;\n\t  this.resumeScheduled = false;\n\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n\t  // when piping, we only care about 'readable' events that happen\n\t  // after read()ing all the bytes and not getting any pushback.\n\t  this.ranOut = false;\n\n\t  // the number of writers that are awaiting a drain event in .pipe()s\n\t  this.awaitDrain = 0;\n\n\t  // if true, a maybeReadMore has been scheduled\n\t  this.readingMore = false;\n\n\t  this.decoder = null;\n\t  this.encoding = null;\n\t  if (options.encoding) {\n\t    this.decoder = new StringDecoder(options.encoding);\n\t    this.encoding = options.encoding;\n\t  }\n\t}\n\tfunction Readable(options) {\n\n\t  if (!(this instanceof Readable)) return new Readable(options);\n\n\t  this._readableState = new ReadableState(options, this);\n\n\t  // legacy\n\t  this.readable = true;\n\n\t  if (options && typeof options.read === 'function') this._read = options.read;\n\n\t  EventEmitter.call(this);\n\t}\n\n\t// Manually shove something into the read() buffer.\n\t// This returns true if the highWaterMark has not been hit yet,\n\t// similar to how Writable.write() returns true if you should\n\t// write() some more.\n\tReadable.prototype.push = function (chunk, encoding) {\n\t  var state = this._readableState;\n\n\t  if (!state.objectMode && typeof chunk === 'string') {\n\t    encoding = encoding || state.defaultEncoding;\n\t    if (encoding !== state.encoding) {\n\t      chunk = Buffer.from(chunk, encoding);\n\t      encoding = '';\n\t    }\n\t  }\n\n\t  return readableAddChunk(this, state, chunk, encoding, false);\n\t};\n\n\t// Unshift should *always* be something directly out of read()\n\tReadable.prototype.unshift = function (chunk) {\n\t  var state = this._readableState;\n\t  return readableAddChunk(this, state, chunk, '', true);\n\t};\n\n\tReadable.prototype.isPaused = function () {\n\t  return this._readableState.flowing === false;\n\t};\n\n\tfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n\t  var er = chunkInvalid(state, chunk);\n\t  if (er) {\n\t    stream.emit('error', er);\n\t  } else if (chunk === null) {\n\t    state.reading = false;\n\t    onEofChunk(stream, state);\n\t  } else if (state.objectMode || chunk && chunk.length > 0) {\n\t    if (state.ended && !addToFront) {\n\t      var e = new Error('stream.push() after EOF');\n\t      stream.emit('error', e);\n\t    } else if (state.endEmitted && addToFront) {\n\t      var _e = new Error('stream.unshift() after end event');\n\t      stream.emit('error', _e);\n\t    } else {\n\t      var skipAdd;\n\t      if (state.decoder && !addToFront && !encoding) {\n\t        chunk = state.decoder.write(chunk);\n\t        skipAdd = !state.objectMode && chunk.length === 0;\n\t      }\n\n\t      if (!addToFront) state.reading = false;\n\n\t      // Don't add to the buffer if we've decoded to an empty string chunk and\n\t      // we're not in object mode\n\t      if (!skipAdd) {\n\t        // if we want the data now, just emit it.\n\t        if (state.flowing && state.length === 0 && !state.sync) {\n\t          stream.emit('data', chunk);\n\t          stream.read(0);\n\t        } else {\n\t          // update the buffer info.\n\t          state.length += state.objectMode ? 1 : chunk.length;\n\t          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n\t          if (state.needReadable) emitReadable(stream);\n\t        }\n\t      }\n\n\t      maybeReadMore(stream, state);\n\t    }\n\t  } else if (!addToFront) {\n\t    state.reading = false;\n\t  }\n\n\t  return needMoreData(state);\n\t}\n\n\t// if it's past the high water mark, we can push in some more.\n\t// Also, if we have no data yet, we can stand some\n\t// more bytes.  This is to work around cases where hwm=0,\n\t// such as the repl.  Also, if the push() triggered a\n\t// readable event, and the user called read(largeNumber) such that\n\t// needReadable was set, then we ought to push more, so that another\n\t// 'readable' event will be triggered.\n\tfunction needMoreData(state) {\n\t  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n\t}\n\n\t// backwards compatibility.\n\tReadable.prototype.setEncoding = function (enc) {\n\t  this._readableState.decoder = new StringDecoder(enc);\n\t  this._readableState.encoding = enc;\n\t  return this;\n\t};\n\n\t// Don't raise the hwm > 8MB\n\tvar MAX_HWM = 0x800000;\n\tfunction computeNewHighWaterMark(n) {\n\t  if (n >= MAX_HWM) {\n\t    n = MAX_HWM;\n\t  } else {\n\t    // Get the next highest power of 2 to prevent increasing hwm excessively in\n\t    // tiny amounts\n\t    n--;\n\t    n |= n >>> 1;\n\t    n |= n >>> 2;\n\t    n |= n >>> 4;\n\t    n |= n >>> 8;\n\t    n |= n >>> 16;\n\t    n++;\n\t  }\n\t  return n;\n\t}\n\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction howMuchToRead(n, state) {\n\t  if (n <= 0 || state.length === 0 && state.ended) return 0;\n\t  if (state.objectMode) return 1;\n\t  if (n !== n) {\n\t    // Only flow one buffer at a time\n\t    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n\t  }\n\t  // If we're asking for more than the current hwm, then raise the hwm.\n\t  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\t  if (n <= state.length) return n;\n\t  // Don't have enough\n\t  if (!state.ended) {\n\t    state.needReadable = true;\n\t    return 0;\n\t  }\n\t  return state.length;\n\t}\n\n\t// you can override either this method, or the async _read(n) below.\n\tReadable.prototype.read = function (n) {\n\t  debug('read', n);\n\t  n = parseInt(n, 10);\n\t  var state = this._readableState;\n\t  var nOrig = n;\n\n\t  if (n !== 0) state.emittedReadable = false;\n\n\t  // if we're doing read(0) to trigger a readable event, but we\n\t  // already have a bunch of data in the buffer, then just trigger\n\t  // the 'readable' event and move on.\n\t  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n\t    debug('read: emitReadable', state.length, state.ended);\n\t    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n\t    return null;\n\t  }\n\n\t  n = howMuchToRead(n, state);\n\n\t  // if we've ended, and we're now clear, then finish it up.\n\t  if (n === 0 && state.ended) {\n\t    if (state.length === 0) endReadable(this);\n\t    return null;\n\t  }\n\n\t  // All the actual chunk generation logic needs to be\n\t  // *below* the call to _read.  The reason is that in certain\n\t  // synthetic stream cases, such as passthrough streams, _read\n\t  // may be a completely synchronous operation which may change\n\t  // the state of the read buffer, providing enough data when\n\t  // before there was *not* enough.\n\t  //\n\t  // So, the steps are:\n\t  // 1. Figure out what the state of things will be after we do\n\t  // a read from the buffer.\n\t  //\n\t  // 2. If that resulting state will trigger a _read, then call _read.\n\t  // Note that this may be asynchronous, or synchronous.  Yes, it is\n\t  // deeply ugly to write APIs this way, but that still doesn't mean\n\t  // that the Readable class should behave improperly, as streams are\n\t  // designed to be sync/async agnostic.\n\t  // Take note if the _read call is sync or async (ie, if the read call\n\t  // has returned yet), so that we know whether or not it's safe to emit\n\t  // 'readable' etc.\n\t  //\n\t  // 3. Actually pull the requested chunks out of the buffer and return.\n\n\t  // if we need a readable event, then we need to do some reading.\n\t  var doRead = state.needReadable;\n\t  debug('need readable', doRead);\n\n\t  // if we currently have less than the highWaterMark, then also read some\n\t  if (state.length === 0 || state.length - n < state.highWaterMark) {\n\t    doRead = true;\n\t    debug('length less than watermark', doRead);\n\t  }\n\n\t  // however, if we've ended, then there's no point, and if we're already\n\t  // reading, then it's unnecessary.\n\t  if (state.ended || state.reading) {\n\t    doRead = false;\n\t    debug('reading or ended', doRead);\n\t  } else if (doRead) {\n\t    debug('do read');\n\t    state.reading = true;\n\t    state.sync = true;\n\t    // if the length is currently zero, then we *need* a readable event.\n\t    if (state.length === 0) state.needReadable = true;\n\t    // call internal read method\n\t    this._read(state.highWaterMark);\n\t    state.sync = false;\n\t    // If _read pushed data synchronously, then `reading` will be false,\n\t    // and we need to re-evaluate how much data we can return to the user.\n\t    if (!state.reading) n = howMuchToRead(nOrig, state);\n\t  }\n\n\t  var ret;\n\t  if (n > 0) ret = fromList(n, state);else ret = null;\n\n\t  if (ret === null) {\n\t    state.needReadable = true;\n\t    n = 0;\n\t  } else {\n\t    state.length -= n;\n\t  }\n\n\t  if (state.length === 0) {\n\t    // If we have nothing in the buffer, then we want to know\n\t    // as soon as we *do* get something into the buffer.\n\t    if (!state.ended) state.needReadable = true;\n\n\t    // If we tried to read() past the EOF, then emit end on the next tick.\n\t    if (nOrig !== n && state.ended) endReadable(this);\n\t  }\n\n\t  if (ret !== null) this.emit('data', ret);\n\n\t  return ret;\n\t};\n\n\tfunction chunkInvalid(state, chunk) {\n\t  var er = null;\n\t  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  return er;\n\t}\n\n\tfunction onEofChunk(stream, state) {\n\t  if (state.ended) return;\n\t  if (state.decoder) {\n\t    var chunk = state.decoder.end();\n\t    if (chunk && chunk.length) {\n\t      state.buffer.push(chunk);\n\t      state.length += state.objectMode ? 1 : chunk.length;\n\t    }\n\t  }\n\t  state.ended = true;\n\n\t  // emit 'readable' now to make sure it gets picked up.\n\t  emitReadable(stream);\n\t}\n\n\t// Don't emit readable right away in sync mode, because this can trigger\n\t// another read() call => stack overflow.  This way, it might trigger\n\t// a nextTick recursion warning, but that's not so bad.\n\tfunction emitReadable(stream) {\n\t  var state = stream._readableState;\n\t  state.needReadable = false;\n\t  if (!state.emittedReadable) {\n\t    debug('emitReadable', state.flowing);\n\t    state.emittedReadable = true;\n\t    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);\n\t  }\n\t}\n\n\tfunction emitReadable_(stream) {\n\t  debug('emit readable');\n\t  stream.emit('readable');\n\t  flow(stream);\n\t}\n\n\t// at this point, the user has presumably seen the 'readable' event,\n\t// and called read() to consume some data.  that may have triggered\n\t// in turn another _read(n) call, in which case reading = true if\n\t// it's in progress.\n\t// However, if we're not ended, or reading, and the length < hwm,\n\t// then go ahead and try to read some more preemptively.\n\tfunction maybeReadMore(stream, state) {\n\t  if (!state.readingMore) {\n\t    state.readingMore = true;\n\t    nextTick(maybeReadMore_, stream, state);\n\t  }\n\t}\n\n\tfunction maybeReadMore_(stream, state) {\n\t  var len = state.length;\n\t  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n\t    debug('maybeReadMore read 0');\n\t    stream.read(0);\n\t    if (len === state.length)\n\t      // didn't get any data, stop spinning.\n\t      break;else len = state.length;\n\t  }\n\t  state.readingMore = false;\n\t}\n\n\t// abstract method.  to be overridden in specific implementation classes.\n\t// call cb(er, data) where data is <= n in length.\n\t// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n\t// arbitrary, and perhaps not very meaningful.\n\tReadable.prototype._read = function (n) {\n\t  this.emit('error', new Error('not implemented'));\n\t};\n\n\tReadable.prototype.pipe = function (dest, pipeOpts) {\n\t  var src = this;\n\t  var state = this._readableState;\n\n\t  switch (state.pipesCount) {\n\t    case 0:\n\t      state.pipes = dest;\n\t      break;\n\t    case 1:\n\t      state.pipes = [state.pipes, dest];\n\t      break;\n\t    default:\n\t      state.pipes.push(dest);\n\t      break;\n\t  }\n\t  state.pipesCount += 1;\n\t  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n\t  var doEnd = (!pipeOpts || pipeOpts.end !== false);\n\n\t  var endFn = doEnd ? onend : cleanup;\n\t  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);\n\n\t  dest.on('unpipe', onunpipe);\n\t  function onunpipe(readable) {\n\t    debug('onunpipe');\n\t    if (readable === src) {\n\t      cleanup();\n\t    }\n\t  }\n\n\t  function onend() {\n\t    debug('onend');\n\t    dest.end();\n\t  }\n\n\t  // when the dest drains, it reduces the awaitDrain counter\n\t  // on the source.  This would be more elegant with a .once()\n\t  // handler in flow(), but adding and removing repeatedly is\n\t  // too slow.\n\t  var ondrain = pipeOnDrain(src);\n\t  dest.on('drain', ondrain);\n\n\t  var cleanedUp = false;\n\t  function cleanup() {\n\t    debug('cleanup');\n\t    // cleanup event handlers once the pipe is broken\n\t    dest.removeListener('close', onclose);\n\t    dest.removeListener('finish', onfinish);\n\t    dest.removeListener('drain', ondrain);\n\t    dest.removeListener('error', onerror);\n\t    dest.removeListener('unpipe', onunpipe);\n\t    src.removeListener('end', onend);\n\t    src.removeListener('end', cleanup);\n\t    src.removeListener('data', ondata);\n\n\t    cleanedUp = true;\n\n\t    // if the reader is waiting for a drain event from this\n\t    // specific writer, then it would cause it to never start\n\t    // flowing again.\n\t    // So, if this is awaiting a drain, then we just call it now.\n\t    // If we don't know, then assume that we are waiting for one.\n\t    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n\t  }\n\n\t  // If the user pushes more data while we're writing to dest then we'll end up\n\t  // in ondata again. However, we only want to increase awaitDrain once because\n\t  // dest will only emit one 'drain' event for the multiple writes.\n\t  // => Introduce a guard on increasing awaitDrain.\n\t  var increasedAwaitDrain = false;\n\t  src.on('data', ondata);\n\t  function ondata(chunk) {\n\t    debug('ondata');\n\t    increasedAwaitDrain = false;\n\t    var ret = dest.write(chunk);\n\t    if (false === ret && !increasedAwaitDrain) {\n\t      // If the user unpiped during `dest.write()`, it is possible\n\t      // to get stuck in a permanently paused state if that write\n\t      // also returned false.\n\t      // => Check whether `dest` is still a piping destination.\n\t      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n\t        debug('false write response, pause', src._readableState.awaitDrain);\n\t        src._readableState.awaitDrain++;\n\t        increasedAwaitDrain = true;\n\t      }\n\t      src.pause();\n\t    }\n\t  }\n\n\t  // if the dest has an error, then stop piping into it.\n\t  // however, don't suppress the throwing behavior for this.\n\t  function onerror(er) {\n\t    debug('onerror', er);\n\t    unpipe();\n\t    dest.removeListener('error', onerror);\n\t    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);\n\t  }\n\n\t  // Make sure our error handler is attached before userland ones.\n\t  prependListener(dest, 'error', onerror);\n\n\t  // Both close and finish should trigger unpipe, but only once.\n\t  function onclose() {\n\t    dest.removeListener('finish', onfinish);\n\t    unpipe();\n\t  }\n\t  dest.once('close', onclose);\n\t  function onfinish() {\n\t    debug('onfinish');\n\t    dest.removeListener('close', onclose);\n\t    unpipe();\n\t  }\n\t  dest.once('finish', onfinish);\n\n\t  function unpipe() {\n\t    debug('unpipe');\n\t    src.unpipe(dest);\n\t  }\n\n\t  // tell the dest that it's being piped to\n\t  dest.emit('pipe', src);\n\n\t  // start the flow if it hasn't been started already.\n\t  if (!state.flowing) {\n\t    debug('pipe resume');\n\t    src.resume();\n\t  }\n\n\t  return dest;\n\t};\n\n\tfunction pipeOnDrain(src) {\n\t  return function () {\n\t    var state = src._readableState;\n\t    debug('pipeOnDrain', state.awaitDrain);\n\t    if (state.awaitDrain) state.awaitDrain--;\n\t    if (state.awaitDrain === 0 && src.listeners('data').length) {\n\t      state.flowing = true;\n\t      flow(src);\n\t    }\n\t  };\n\t}\n\n\tReadable.prototype.unpipe = function (dest) {\n\t  var state = this._readableState;\n\n\t  // if we're not piping anywhere, then do nothing.\n\t  if (state.pipesCount === 0) return this;\n\n\t  // just one destination.  most common case.\n\t  if (state.pipesCount === 1) {\n\t    // passed in one, but it's not the right one.\n\t    if (dest && dest !== state.pipes) return this;\n\n\t    if (!dest) dest = state.pipes;\n\n\t    // got a match.\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t    if (dest) dest.emit('unpipe', this);\n\t    return this;\n\t  }\n\n\t  // slow case. multiple pipe destinations.\n\n\t  if (!dest) {\n\t    // remove all.\n\t    var dests = state.pipes;\n\t    var len = state.pipesCount;\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\n\t    for (var _i = 0; _i < len; _i++) {\n\t      dests[_i].emit('unpipe', this);\n\t    }return this;\n\t  }\n\n\t  // try to find the right one.\n\t  var i = indexOf(state.pipes, dest);\n\t  if (i === -1) return this;\n\n\t  state.pipes.splice(i, 1);\n\t  state.pipesCount -= 1;\n\t  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n\t  dest.emit('unpipe', this);\n\n\t  return this;\n\t};\n\n\t// set up data events if they are asked for\n\t// Ensure readable listeners eventually get something\n\tReadable.prototype.on = function (ev, fn) {\n\t  var res = EventEmitter.prototype.on.call(this, ev, fn);\n\n\t  if (ev === 'data') {\n\t    // Start flowing on next tick if stream isn't explicitly paused\n\t    if (this._readableState.flowing !== false) this.resume();\n\t  } else if (ev === 'readable') {\n\t    var state = this._readableState;\n\t    if (!state.endEmitted && !state.readableListening) {\n\t      state.readableListening = state.needReadable = true;\n\t      state.emittedReadable = false;\n\t      if (!state.reading) {\n\t        nextTick(nReadingNextTick, this);\n\t      } else if (state.length) {\n\t        emitReadable(this);\n\t      }\n\t    }\n\t  }\n\n\t  return res;\n\t};\n\tReadable.prototype.addListener = Readable.prototype.on;\n\n\tfunction nReadingNextTick(self) {\n\t  debug('readable nexttick read 0');\n\t  self.read(0);\n\t}\n\n\t// pause() and resume() are remnants of the legacy readable stream API\n\t// If the user uses them, then switch into old mode.\n\tReadable.prototype.resume = function () {\n\t  var state = this._readableState;\n\t  if (!state.flowing) {\n\t    debug('resume');\n\t    state.flowing = true;\n\t    resume(this, state);\n\t  }\n\t  return this;\n\t};\n\n\tfunction resume(stream, state) {\n\t  if (!state.resumeScheduled) {\n\t    state.resumeScheduled = true;\n\t    nextTick(resume_, stream, state);\n\t  }\n\t}\n\n\tfunction resume_(stream, state) {\n\t  if (!state.reading) {\n\t    debug('resume read 0');\n\t    stream.read(0);\n\t  }\n\n\t  state.resumeScheduled = false;\n\t  state.awaitDrain = 0;\n\t  stream.emit('resume');\n\t  flow(stream);\n\t  if (state.flowing && !state.reading) stream.read(0);\n\t}\n\n\tReadable.prototype.pause = function () {\n\t  debug('call pause flowing=%j', this._readableState.flowing);\n\t  if (false !== this._readableState.flowing) {\n\t    debug('pause');\n\t    this._readableState.flowing = false;\n\t    this.emit('pause');\n\t  }\n\t  return this;\n\t};\n\n\tfunction flow(stream) {\n\t  var state = stream._readableState;\n\t  debug('flow', state.flowing);\n\t  while (state.flowing && stream.read() !== null) {}\n\t}\n\n\t// wrap an old-style stream as the async data source.\n\t// This is *not* part of the readable stream interface.\n\t// It is an ugly unfortunate mess of history.\n\tReadable.prototype.wrap = function (stream) {\n\t  var state = this._readableState;\n\t  var paused = false;\n\n\t  var self = this;\n\t  stream.on('end', function () {\n\t    debug('wrapped end');\n\t    if (state.decoder && !state.ended) {\n\t      var chunk = state.decoder.end();\n\t      if (chunk && chunk.length) self.push(chunk);\n\t    }\n\n\t    self.push(null);\n\t  });\n\n\t  stream.on('data', function (chunk) {\n\t    debug('wrapped data');\n\t    if (state.decoder) chunk = state.decoder.write(chunk);\n\n\t    // don't skip over falsy values in objectMode\n\t    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n\t    var ret = self.push(chunk);\n\t    if (!ret) {\n\t      paused = true;\n\t      stream.pause();\n\t    }\n\t  });\n\n\t  // proxy all the other methods.\n\t  // important when wrapping filters and duplexes.\n\t  for (var i in stream) {\n\t    if (this[i] === undefined && typeof stream[i] === 'function') {\n\t      this[i] = function (method) {\n\t        return function () {\n\t          return stream[method].apply(stream, arguments);\n\t        };\n\t      }(i);\n\t    }\n\t  }\n\n\t  // proxy certain important events.\n\t  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n\t  forEach(events, function (ev) {\n\t    stream.on(ev, self.emit.bind(self, ev));\n\t  });\n\n\t  // when we try to consume some more bytes, simply unpause the\n\t  // underlying stream.\n\t  self._read = function (n) {\n\t    debug('wrapped _read', n);\n\t    if (paused) {\n\t      paused = false;\n\t      stream.resume();\n\t    }\n\t  };\n\n\t  return self;\n\t};\n\n\t// exposed for testing purposes only.\n\tReadable._fromList = fromList;\n\n\t// Pluck off n bytes from an array of buffers.\n\t// Length is the combined lengths of all the buffers in the list.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction fromList(n, state) {\n\t  // nothing buffered\n\t  if (state.length === 0) return null;\n\n\t  var ret;\n\t  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n\t    // read it all, truncate the list\n\t    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n\t    state.buffer.clear();\n\t  } else {\n\t    // read part of list\n\t    ret = fromListPartial(n, state.buffer, state.decoder);\n\t  }\n\n\t  return ret;\n\t}\n\n\t// Extracts only enough buffered data to satisfy the amount requested.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction fromListPartial(n, list, hasStrings) {\n\t  var ret;\n\t  if (n < list.head.data.length) {\n\t    // slice is the same for buffers and strings\n\t    ret = list.head.data.slice(0, n);\n\t    list.head.data = list.head.data.slice(n);\n\t  } else if (n === list.head.data.length) {\n\t    // first chunk is a perfect match\n\t    ret = list.shift();\n\t  } else {\n\t    // result spans more than one buffer\n\t    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n\t  }\n\t  return ret;\n\t}\n\n\t// Copies a specified amount of characters from the list of buffered data\n\t// chunks.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction copyFromBufferString(n, list) {\n\t  var p = list.head;\n\t  var c = 1;\n\t  var ret = p.data;\n\t  n -= ret.length;\n\t  while (p = p.next) {\n\t    var str = p.data;\n\t    var nb = n > str.length ? str.length : n;\n\t    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n\t    n -= nb;\n\t    if (n === 0) {\n\t      if (nb === str.length) {\n\t        ++c;\n\t        if (p.next) list.head = p.next;else list.head = list.tail = null;\n\t      } else {\n\t        list.head = p;\n\t        p.data = str.slice(nb);\n\t      }\n\t      break;\n\t    }\n\t    ++c;\n\t  }\n\t  list.length -= c;\n\t  return ret;\n\t}\n\n\t// Copies a specified amount of bytes from the list of buffered data chunks.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction copyFromBuffer(n, list) {\n\t  var ret = Buffer.allocUnsafe(n);\n\t  var p = list.head;\n\t  var c = 1;\n\t  p.data.copy(ret);\n\t  n -= p.data.length;\n\t  while (p = p.next) {\n\t    var buf = p.data;\n\t    var nb = n > buf.length ? buf.length : n;\n\t    buf.copy(ret, ret.length - n, 0, nb);\n\t    n -= nb;\n\t    if (n === 0) {\n\t      if (nb === buf.length) {\n\t        ++c;\n\t        if (p.next) list.head = p.next;else list.head = list.tail = null;\n\t      } else {\n\t        list.head = p;\n\t        p.data = buf.slice(nb);\n\t      }\n\t      break;\n\t    }\n\t    ++c;\n\t  }\n\t  list.length -= c;\n\t  return ret;\n\t}\n\n\tfunction endReadable(stream) {\n\t  var state = stream._readableState;\n\n\t  // If we get here before consuming all the bytes, then that is a\n\t  // bug in node.  Should never happen.\n\t  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n\t  if (!state.endEmitted) {\n\t    state.ended = true;\n\t    nextTick(endReadableNT, state, stream);\n\t  }\n\t}\n\n\tfunction endReadableNT(state, stream) {\n\t  // Check that we didn't get one last unshift.\n\t  if (!state.endEmitted && state.length === 0) {\n\t    state.endEmitted = true;\n\t    stream.readable = false;\n\t    stream.emit('end');\n\t  }\n\t}\n\n\tfunction forEach(xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\n\tfunction indexOf(xs, x) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    if (xs[i] === x) return i;\n\t  }\n\t  return -1;\n\t}\n\n\t// A bit simpler than readable streams.\n\t// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n\t// the drain event emission and buffering.\n\n\tWritable.WritableState = WritableState;\n\tinherits(Writable, EventEmitter);\n\n\tfunction nop() {}\n\n\tfunction WriteReq(chunk, encoding, cb) {\n\t  this.chunk = chunk;\n\t  this.encoding = encoding;\n\t  this.callback = cb;\n\t  this.next = null;\n\t}\n\n\tfunction WritableState(options, stream) {\n\t  Object.defineProperty(this, 'buffer', {\n\t    get: deprecate(function () {\n\t      return this.getBuffer();\n\t    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n\t  });\n\t  options = options || {};\n\n\t  // object stream flag to indicate whether or not this stream\n\t  // contains buffers or objects.\n\t  this.objectMode = !!options.objectMode;\n\n\t  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n\t  // the point at which write() starts returning false\n\t  // Note: 0 is a valid value, means that we always return false if\n\t  // the entire buffer is not flushed immediately on write()\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n\t  // cast to ints.\n\t  this.highWaterMark = ~ ~this.highWaterMark;\n\n\t  this.needDrain = false;\n\t  // at the start of calling end()\n\t  this.ending = false;\n\t  // when end() has been called, and returned\n\t  this.ended = false;\n\t  // when 'finish' is emitted\n\t  this.finished = false;\n\n\t  // should we decode strings into buffers before passing to _write?\n\t  // this is here so that some node-core streams can optimize string\n\t  // handling at a lower level.\n\t  var noDecode = options.decodeStrings === false;\n\t  this.decodeStrings = !noDecode;\n\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n\t  // not an actual buffer we keep track of, but a measurement\n\t  // of how much we're waiting to get pushed to some underlying\n\t  // socket or file.\n\t  this.length = 0;\n\n\t  // a flag to see when we're in the middle of a write.\n\t  this.writing = false;\n\n\t  // when true all writes will be buffered until .uncork() call\n\t  this.corked = 0;\n\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\n\t  // a flag to know if we're processing previously buffered items, which\n\t  // may call the _write() callback in the same tick, so that we don't\n\t  // end up in an overlapped onwrite situation.\n\t  this.bufferProcessing = false;\n\n\t  // the callback that's passed to _write(chunk,cb)\n\t  this.onwrite = function (er) {\n\t    onwrite(stream, er);\n\t  };\n\n\t  // the callback that the user supplies to write(chunk,encoding,cb)\n\t  this.writecb = null;\n\n\t  // the amount that is being written when _write is called.\n\t  this.writelen = 0;\n\n\t  this.bufferedRequest = null;\n\t  this.lastBufferedRequest = null;\n\n\t  // number of pending user-supplied write callbacks\n\t  // this must be 0 before 'finish' can be emitted\n\t  this.pendingcb = 0;\n\n\t  // emit prefinish if the only thing we're waiting for is _write cbs\n\t  // This is relevant for synchronous Transform streams\n\t  this.prefinished = false;\n\n\t  // True if the error was already emitted and should not be thrown again\n\t  this.errorEmitted = false;\n\n\t  // count buffered requests\n\t  this.bufferedRequestCount = 0;\n\n\t  // allocate the first CorkedRequest, there is always\n\t  // one allocated and free to use, and we maintain at most two\n\t  this.corkedRequestsFree = new CorkedRequest(this);\n\t}\n\n\tWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n\t  var current = this.bufferedRequest;\n\t  var out = [];\n\t  while (current) {\n\t    out.push(current);\n\t    current = current.next;\n\t  }\n\t  return out;\n\t};\n\tfunction Writable(options) {\n\n\t  // Writable ctor is applied to Duplexes, though they're not\n\t  // instanceof Writable, they're instanceof Readable.\n\t  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n\t  this._writableState = new WritableState(options, this);\n\n\t  // legacy.\n\t  this.writable = true;\n\n\t  if (options) {\n\t    if (typeof options.write === 'function') this._write = options.write;\n\n\t    if (typeof options.writev === 'function') this._writev = options.writev;\n\t  }\n\n\t  EventEmitter.call(this);\n\t}\n\n\t// Otherwise people can pipe Writable streams, which is just wrong.\n\tWritable.prototype.pipe = function () {\n\t  this.emit('error', new Error('Cannot pipe, not readable'));\n\t};\n\n\tfunction writeAfterEnd(stream, cb) {\n\t  var er = new Error('write after end');\n\t  // TODO: defer error events consistently everywhere, not just the cb\n\t  stream.emit('error', er);\n\t  nextTick(cb, er);\n\t}\n\n\t// If we get something that is not a buffer, string, null, or undefined,\n\t// and we're not in objectMode, then that's an error.\n\t// Otherwise stream chunks are all considered to be of length=1, and the\n\t// watermarks determine how many objects to keep in the buffer, rather than\n\t// how many bytes or characters.\n\tfunction validChunk(stream, state, chunk, cb) {\n\t  var valid = true;\n\t  var er = false;\n\t  // Always throw error if a null is written\n\t  // if we are not in object mode then throw\n\t  // if it is not a buffer, string, or undefined.\n\t  if (chunk === null) {\n\t    er = new TypeError('May not write null values to stream');\n\t  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  if (er) {\n\t    stream.emit('error', er);\n\t    nextTick(cb, er);\n\t    valid = false;\n\t  }\n\t  return valid;\n\t}\n\n\tWritable.prototype.write = function (chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t  var ret = false;\n\n\t  if (typeof encoding === 'function') {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\n\t  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n\t  if (typeof cb !== 'function') cb = nop;\n\n\t  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n\t    state.pendingcb++;\n\t    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\t  }\n\n\t  return ret;\n\t};\n\n\tWritable.prototype.cork = function () {\n\t  var state = this._writableState;\n\n\t  state.corked++;\n\t};\n\n\tWritable.prototype.uncork = function () {\n\t  var state = this._writableState;\n\n\t  if (state.corked) {\n\t    state.corked--;\n\n\t    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n\t  }\n\t};\n\n\tWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n\t  // node::ParseEncoding() requires lower case.\n\t  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n\t  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n\t  this._writableState.defaultEncoding = encoding;\n\t  return this;\n\t};\n\n\tfunction decodeChunk(state, chunk, encoding) {\n\t  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n\t    chunk = Buffer.from(chunk, encoding);\n\t  }\n\t  return chunk;\n\t}\n\n\t// if we're already writing something, then just put this\n\t// in the queue, and wait our turn.  Otherwise, call _write\n\t// If we return false, then we need a drain event, so set that flag.\n\tfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n\t  chunk = decodeChunk(state, chunk, encoding);\n\n\t  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n\t  var len = state.objectMode ? 1 : chunk.length;\n\n\t  state.length += len;\n\n\t  var ret = state.length < state.highWaterMark;\n\t  // we must ensure that previous needDrain will not be reset to false.\n\t  if (!ret) state.needDrain = true;\n\n\t  if (state.writing || state.corked) {\n\t    var last = state.lastBufferedRequest;\n\t    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n\t    if (last) {\n\t      last.next = state.lastBufferedRequest;\n\t    } else {\n\t      state.bufferedRequest = state.lastBufferedRequest;\n\t    }\n\t    state.bufferedRequestCount += 1;\n\t  } else {\n\t    doWrite(stream, state, false, len, chunk, encoding, cb);\n\t  }\n\n\t  return ret;\n\t}\n\n\tfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n\t  state.writelen = len;\n\t  state.writecb = cb;\n\t  state.writing = true;\n\t  state.sync = true;\n\t  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n\t  state.sync = false;\n\t}\n\n\tfunction onwriteError(stream, state, sync, er, cb) {\n\t  --state.pendingcb;\n\t  if (sync) nextTick(cb, er);else cb(er);\n\n\t  stream._writableState.errorEmitted = true;\n\t  stream.emit('error', er);\n\t}\n\n\tfunction onwriteStateUpdate(state) {\n\t  state.writing = false;\n\t  state.writecb = null;\n\t  state.length -= state.writelen;\n\t  state.writelen = 0;\n\t}\n\n\tfunction onwrite(stream, er) {\n\t  var state = stream._writableState;\n\t  var sync = state.sync;\n\t  var cb = state.writecb;\n\n\t  onwriteStateUpdate(state);\n\n\t  if (er) onwriteError(stream, state, sync, er, cb);else {\n\t    // Check if we're actually ready to finish, but don't emit yet\n\t    var finished = needFinish(state);\n\n\t    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n\t      clearBuffer(stream, state);\n\t    }\n\n\t    if (sync) {\n\t      /*<replacement>*/\n\t        nextTick(afterWrite, stream, state, finished, cb);\n\t      /*</replacement>*/\n\t    } else {\n\t        afterWrite(stream, state, finished, cb);\n\t      }\n\t  }\n\t}\n\n\tfunction afterWrite(stream, state, finished, cb) {\n\t  if (!finished) onwriteDrain(stream, state);\n\t  state.pendingcb--;\n\t  cb();\n\t  finishMaybe(stream, state);\n\t}\n\n\t// Must force callback to be called on nextTick, so that we don't\n\t// emit 'drain' before the write() consumer gets the 'false' return\n\t// value, and has a chance to attach a 'drain' listener.\n\tfunction onwriteDrain(stream, state) {\n\t  if (state.length === 0 && state.needDrain) {\n\t    state.needDrain = false;\n\t    stream.emit('drain');\n\t  }\n\t}\n\n\t// if there's something in the buffer waiting, then process it\n\tfunction clearBuffer(stream, state) {\n\t  state.bufferProcessing = true;\n\t  var entry = state.bufferedRequest;\n\n\t  if (stream._writev && entry && entry.next) {\n\t    // Fast case, write everything using _writev()\n\t    var l = state.bufferedRequestCount;\n\t    var buffer = new Array(l);\n\t    var holder = state.corkedRequestsFree;\n\t    holder.entry = entry;\n\n\t    var count = 0;\n\t    while (entry) {\n\t      buffer[count] = entry;\n\t      entry = entry.next;\n\t      count += 1;\n\t    }\n\n\t    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n\t    // doWrite is almost always async, defer these to save a bit of time\n\t    // as the hot path ends with doWrite\n\t    state.pendingcb++;\n\t    state.lastBufferedRequest = null;\n\t    if (holder.next) {\n\t      state.corkedRequestsFree = holder.next;\n\t      holder.next = null;\n\t    } else {\n\t      state.corkedRequestsFree = new CorkedRequest(state);\n\t    }\n\t  } else {\n\t    // Slow case, write chunks one-by-one\n\t    while (entry) {\n\t      var chunk = entry.chunk;\n\t      var encoding = entry.encoding;\n\t      var cb = entry.callback;\n\t      var len = state.objectMode ? 1 : chunk.length;\n\n\t      doWrite(stream, state, false, len, chunk, encoding, cb);\n\t      entry = entry.next;\n\t      // if we didn't call the onwrite immediately, then\n\t      // it means that we need to wait until it does.\n\t      // also, that means that the chunk and cb are currently\n\t      // being processed, so move the buffer counter past them.\n\t      if (state.writing) {\n\t        break;\n\t      }\n\t    }\n\n\t    if (entry === null) state.lastBufferedRequest = null;\n\t  }\n\n\t  state.bufferedRequestCount = 0;\n\t  state.bufferedRequest = entry;\n\t  state.bufferProcessing = false;\n\t}\n\n\tWritable.prototype._write = function (chunk, encoding, cb) {\n\t  cb(new Error('not implemented'));\n\t};\n\n\tWritable.prototype._writev = null;\n\n\tWritable.prototype.end = function (chunk, encoding, cb) {\n\t  var state = this._writableState;\n\n\t  if (typeof chunk === 'function') {\n\t    cb = chunk;\n\t    chunk = null;\n\t    encoding = null;\n\t  } else if (typeof encoding === 'function') {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\n\t  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n\t  // .end() fully uncorks\n\t  if (state.corked) {\n\t    state.corked = 1;\n\t    this.uncork();\n\t  }\n\n\t  // ignore unnecessary end() calls.\n\t  if (!state.ending && !state.finished) endWritable(this, state, cb);\n\t};\n\n\tfunction needFinish(state) {\n\t  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n\t}\n\n\tfunction prefinish(stream, state) {\n\t  if (!state.prefinished) {\n\t    state.prefinished = true;\n\t    stream.emit('prefinish');\n\t  }\n\t}\n\n\tfunction finishMaybe(stream, state) {\n\t  var need = needFinish(state);\n\t  if (need) {\n\t    if (state.pendingcb === 0) {\n\t      prefinish(stream, state);\n\t      state.finished = true;\n\t      stream.emit('finish');\n\t    } else {\n\t      prefinish(stream, state);\n\t    }\n\t  }\n\t  return need;\n\t}\n\n\tfunction endWritable(stream, state, cb) {\n\t  state.ending = true;\n\t  finishMaybe(stream, state);\n\t  if (cb) {\n\t    if (state.finished) nextTick(cb);else stream.once('finish', cb);\n\t  }\n\t  state.ended = true;\n\t  stream.writable = false;\n\t}\n\n\t// It seems a linked list but it is not\n\t// there will be only 2 of these for each stream\n\tfunction CorkedRequest(state) {\n\t  var _this = this;\n\n\t  this.next = null;\n\t  this.entry = null;\n\n\t  this.finish = function (err) {\n\t    var entry = _this.entry;\n\t    _this.entry = null;\n\t    while (entry) {\n\t      var cb = entry.callback;\n\t      state.pendingcb--;\n\t      cb(err);\n\t      entry = entry.next;\n\t    }\n\t    if (state.corkedRequestsFree) {\n\t      state.corkedRequestsFree.next = _this;\n\t    } else {\n\t      state.corkedRequestsFree = _this;\n\t    }\n\t  };\n\t}\n\n\tinherits(Duplex, Readable);\n\n\tvar keys = Object.keys(Writable.prototype);\n\tfor (var v = 0; v < keys.length; v++) {\n\t  var method = keys[v];\n\t  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n\t}\n\tfunction Duplex(options) {\n\t  if (!(this instanceof Duplex)) return new Duplex(options);\n\n\t  Readable.call(this, options);\n\t  Writable.call(this, options);\n\n\t  if (options && options.readable === false) this.readable = false;\n\n\t  if (options && options.writable === false) this.writable = false;\n\n\t  this.allowHalfOpen = true;\n\t  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n\t  this.once('end', onend);\n\t}\n\n\t// the no-half-open enforcer\n\tfunction onend() {\n\t  // if we allow half-open state, or if the writable side ended,\n\t  // then we're ok.\n\t  if (this.allowHalfOpen || this._writableState.ended) return;\n\n\t  // no more data can be written.\n\t  // But allow more writes to happen in this tick.\n\t  nextTick(onEndNT, this);\n\t}\n\n\tfunction onEndNT(self) {\n\t  self.end();\n\t}\n\n\t// a transform stream is a readable/writable stream where you do\n\t// something with the data.  Sometimes it's called a \"filter\",\n\t// but that's not a great name for it, since that implies a thing where\n\t// some bits pass through, and others are simply ignored.  (That would\n\t// be a valid example of a transform, of course.)\n\t//\n\t// While the output is causally related to the input, it's not a\n\t// necessarily symmetric or synchronous transformation.  For example,\n\t// a zlib stream might take multiple plain-text writes(), and then\n\t// emit a single compressed chunk some time in the future.\n\t//\n\t// Here's how this works:\n\t//\n\t// The Transform stream has all the aspects of the readable and writable\n\t// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n\t// internally, and returns false if there's a lot of pending writes\n\t// buffered up.  When you call read(), that calls _read(n) until\n\t// there's enough pending readable data buffered up.\n\t//\n\t// In a transform stream, the written data is placed in a buffer.  When\n\t// _read(n) is called, it transforms the queued up data, calling the\n\t// buffered _write cb's as it consumes chunks.  If consuming a single\n\t// written chunk would result in multiple output chunks, then the first\n\t// outputted bit calls the readcb, and subsequent chunks just go into\n\t// the read buffer, and will cause it to emit 'readable' if necessary.\n\t//\n\t// This way, back-pressure is actually determined by the reading side,\n\t// since _read has to be called to start processing a new chunk.  However,\n\t// a pathological inflate type of transform can cause excessive buffering\n\t// here.  For example, imagine a stream where every byte of input is\n\t// interpreted as an integer from 0-255, and then results in that many\n\t// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n\t// 1kb of data being output.  In this case, you could write a very small\n\t// amount of input, and end up with a very large amount of output.  In\n\t// such a pathological inflating mechanism, there'd be no way to tell\n\t// the system to stop doing the transform.  A single 4MB write could\n\t// cause the system to run out of memory.\n\t//\n\t// However, even in such a pathological case, only a single written chunk\n\t// would be consumed, and then the rest would wait (un-transformed) until\n\t// the results of the previous transformed chunk were consumed.\n\n\tinherits(Transform, Duplex);\n\n\tfunction TransformState(stream) {\n\t  this.afterTransform = function (er, data) {\n\t    return afterTransform(stream, er, data);\n\t  };\n\n\t  this.needTransform = false;\n\t  this.transforming = false;\n\t  this.writecb = null;\n\t  this.writechunk = null;\n\t  this.writeencoding = null;\n\t}\n\n\tfunction afterTransform(stream, er, data) {\n\t  var ts = stream._transformState;\n\t  ts.transforming = false;\n\n\t  var cb = ts.writecb;\n\n\t  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n\t  ts.writechunk = null;\n\t  ts.writecb = null;\n\n\t  if (data !== null && data !== undefined) stream.push(data);\n\n\t  cb(er);\n\n\t  var rs = stream._readableState;\n\t  rs.reading = false;\n\t  if (rs.needReadable || rs.length < rs.highWaterMark) {\n\t    stream._read(rs.highWaterMark);\n\t  }\n\t}\n\tfunction Transform(options) {\n\t  if (!(this instanceof Transform)) return new Transform(options);\n\n\t  Duplex.call(this, options);\n\n\t  this._transformState = new TransformState(this);\n\n\t  // when the writable side finishes, then flush out anything remaining.\n\t  var stream = this;\n\n\t  // start out asking for a readable event once data is transformed.\n\t  this._readableState.needReadable = true;\n\n\t  // we have implemented the _read method, and done the other things\n\t  // that Readable wants before the first _read call, so unset the\n\t  // sync guard flag.\n\t  this._readableState.sync = false;\n\n\t  if (options) {\n\t    if (typeof options.transform === 'function') this._transform = options.transform;\n\n\t    if (typeof options.flush === 'function') this._flush = options.flush;\n\t  }\n\n\t  this.once('prefinish', function () {\n\t    if (typeof this._flush === 'function') this._flush(function (er) {\n\t      done(stream, er);\n\t    });else done(stream);\n\t  });\n\t}\n\n\tTransform.prototype.push = function (chunk, encoding) {\n\t  this._transformState.needTransform = false;\n\t  return Duplex.prototype.push.call(this, chunk, encoding);\n\t};\n\n\t// This is the part where you do stuff!\n\t// override this function in implementation classes.\n\t// 'chunk' is an input chunk.\n\t//\n\t// Call `push(newChunk)` to pass along transformed output\n\t// to the readable side.  You may call 'push' zero or more times.\n\t//\n\t// Call `cb(err)` when you are done with this chunk.  If you pass\n\t// an error, then that'll put the hurt on the whole operation.  If you\n\t// never call cb(), then you'll never get another chunk.\n\tTransform.prototype._transform = function (chunk, encoding, cb) {\n\t  throw new Error('Not implemented');\n\t};\n\n\tTransform.prototype._write = function (chunk, encoding, cb) {\n\t  var ts = this._transformState;\n\t  ts.writecb = cb;\n\t  ts.writechunk = chunk;\n\t  ts.writeencoding = encoding;\n\t  if (!ts.transforming) {\n\t    var rs = this._readableState;\n\t    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n\t  }\n\t};\n\n\t// Doesn't matter what the args are here.\n\t// _transform does all the work.\n\t// That we got here means that the readable side wants more data.\n\tTransform.prototype._read = function (n) {\n\t  var ts = this._transformState;\n\n\t  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n\t    ts.transforming = true;\n\t    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n\t  } else {\n\t    // mark that we need a transform, so that any data that comes in\n\t    // will get processed, now that we've asked for it.\n\t    ts.needTransform = true;\n\t  }\n\t};\n\n\tfunction done(stream, er) {\n\t  if (er) return stream.emit('error', er);\n\n\t  // if there's nothing in the write buffer, then that means\n\t  // that nothing more will ever be provided\n\t  var ws = stream._writableState;\n\t  var ts = stream._transformState;\n\n\t  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n\t  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n\t  return stream.push(null);\n\t}\n\n\tinherits(PassThrough, Transform);\n\tfunction PassThrough(options) {\n\t  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n\t  Transform.call(this, options);\n\t}\n\n\tPassThrough.prototype._transform = function (chunk, encoding, cb) {\n\t  cb(null, chunk);\n\t};\n\n\tinherits(Stream, EventEmitter);\n\tStream.Readable = Readable;\n\tStream.Writable = Writable;\n\tStream.Duplex = Duplex;\n\tStream.Transform = Transform;\n\tStream.PassThrough = PassThrough;\n\n\t// Backwards-compat with node 0.4.x\n\tStream.Stream = Stream;\n\n\t// old-style streams.  Note that the pipe method (the only relevant\n\t// part of this class) is overridden in the Readable class.\n\n\tfunction Stream() {\n\t  EventEmitter.call(this);\n\t}\n\n\tStream.prototype.pipe = function(dest, options) {\n\t  var source = this;\n\n\t  function ondata(chunk) {\n\t    if (dest.writable) {\n\t      if (false === dest.write(chunk) && source.pause) {\n\t        source.pause();\n\t      }\n\t    }\n\t  }\n\n\t  source.on('data', ondata);\n\n\t  function ondrain() {\n\t    if (source.readable && source.resume) {\n\t      source.resume();\n\t    }\n\t  }\n\n\t  dest.on('drain', ondrain);\n\n\t  // If the 'end' option is not supplied, dest.end() will be called when\n\t  // source gets the 'end' or 'close' events.  Only dest.end() once.\n\t  if (!dest._isStdio && (!options || options.end !== false)) {\n\t    source.on('end', onend);\n\t    source.on('close', onclose);\n\t  }\n\n\t  var didOnEnd = false;\n\t  function onend() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\n\t    dest.end();\n\t  }\n\n\n\t  function onclose() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\n\t    if (typeof dest.destroy === 'function') dest.destroy();\n\t  }\n\n\t  // don't leave dangling pipes when there are errors.\n\t  function onerror(er) {\n\t    cleanup();\n\t    if (EventEmitter.listenerCount(this, 'error') === 0) {\n\t      throw er; // Unhandled stream error in pipe.\n\t    }\n\t  }\n\n\t  source.on('error', onerror);\n\t  dest.on('error', onerror);\n\n\t  // remove all the event listeners that were added.\n\t  function cleanup() {\n\t    source.removeListener('data', ondata);\n\t    dest.removeListener('drain', ondrain);\n\n\t    source.removeListener('end', onend);\n\t    source.removeListener('close', onclose);\n\n\t    source.removeListener('error', onerror);\n\t    dest.removeListener('error', onerror);\n\n\t    source.removeListener('end', cleanup);\n\t    source.removeListener('close', cleanup);\n\n\t    dest.removeListener('close', cleanup);\n\t  }\n\n\t  source.on('end', cleanup);\n\t  source.on('close', cleanup);\n\n\t  dest.on('close', cleanup);\n\n\t  dest.emit('pipe', source);\n\n\t  // Allow for unix-like usage: A.pipe(B).pipe(C)\n\t  return dest;\n\t};\n\n\tvar rStates = {\n\t  UNSENT: 0,\n\t  OPENED: 1,\n\t  HEADERS_RECEIVED: 2,\n\t  LOADING: 3,\n\t  DONE: 4\n\t};\n\tfunction IncomingMessage(xhr, response, mode) {\n\t  var self = this;\n\t  Readable.call(self);\n\n\t  self._mode = mode;\n\t  self.headers = {};\n\t  self.rawHeaders = [];\n\t  self.trailers = {};\n\t  self.rawTrailers = [];\n\n\t  // Fake the 'close' event, but only once 'end' fires\n\t  self.on('end', function() {\n\t    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t    browser$1.nextTick(function() {\n\t      self.emit('close');\n\t    });\n\t  });\n\t  var read;\n\t  if (mode === 'fetch') {\n\t    self._fetchResponse = response;\n\n\t    self.url = response.url;\n\t    self.statusCode = response.status;\n\t    self.statusMessage = response.statusText;\n\t      // backwards compatible version of for (<item> of <iterable>):\n\t      // for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)\n\t    for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {\n\t      self.headers[header[0].toLowerCase()] = header[1];\n\t      self.rawHeaders.push(header[0], header[1]);\n\t    }\n\n\t    // TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed\n\t    var reader = response.body.getReader();\n\n\t    read = function () {\n\t      reader.read().then(function(result) {\n\t        if (self._destroyed)\n\t          return\n\t        if (result.done) {\n\t          self.push(null);\n\t          return\n\t        }\n\t        self.push(new Buffer(result.value));\n\t        read();\n\t      });\n\t    };\n\t    read();\n\n\t  } else {\n\t    self._xhr = xhr;\n\t    self._pos = 0;\n\n\t    self.url = xhr.responseURL;\n\t    self.statusCode = xhr.status;\n\t    self.statusMessage = xhr.statusText;\n\t    var headers = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n\t    headers.forEach(function(header) {\n\t      var matches = header.match(/^([^:]+):\\s*(.*)/);\n\t      if (matches) {\n\t        var key = matches[1].toLowerCase();\n\t        if (key === 'set-cookie') {\n\t          if (self.headers[key] === undefined) {\n\t            self.headers[key] = [];\n\t          }\n\t          self.headers[key].push(matches[2]);\n\t        } else if (self.headers[key] !== undefined) {\n\t          self.headers[key] += ', ' + matches[2];\n\t        } else {\n\t          self.headers[key] = matches[2];\n\t        }\n\t        self.rawHeaders.push(matches[1], matches[2]);\n\t      }\n\t    });\n\n\t    self._charset = 'x-user-defined';\n\t    if (!overrideMimeType) {\n\t      var mimeType = self.rawHeaders['mime-type'];\n\t      if (mimeType) {\n\t        var charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/);\n\t        if (charsetMatch) {\n\t          self._charset = charsetMatch[1].toLowerCase();\n\t        }\n\t      }\n\t      if (!self._charset)\n\t        self._charset = 'utf-8'; // best guess\n\t    }\n\t  }\n\t}\n\n\tinherits(IncomingMessage, Readable);\n\n\tIncomingMessage.prototype._read = function() {};\n\n\tIncomingMessage.prototype._onXHRProgress = function() {\n\t  var self = this;\n\n\t  var xhr = self._xhr;\n\n\t  var response = null;\n\t  switch (self._mode) {\n\t  case 'text:vbarray': // For IE9\n\t    if (xhr.readyState !== rStates.DONE)\n\t      break\n\t    try {\n\t      // This fails in IE8\n\t      response = new global$1.VBArray(xhr.responseBody).toArray();\n\t    } catch (e) {\n\t      // pass\n\t    }\n\t    if (response !== null) {\n\t      self.push(new Buffer(response));\n\t      break\n\t    }\n\t    // Falls through in IE8\n\t  case 'text':\n\t    try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t      response = xhr.responseText;\n\t    } catch (e) {\n\t      self._mode = 'text:vbarray';\n\t      break\n\t    }\n\t    if (response.length > self._pos) {\n\t      var newData = response.substr(self._pos);\n\t      if (self._charset === 'x-user-defined') {\n\t        var buffer = new Buffer(newData.length);\n\t        for (var i = 0; i < newData.length; i++)\n\t          buffer[i] = newData.charCodeAt(i) & 0xff;\n\n\t        self.push(buffer);\n\t      } else {\n\t        self.push(newData, self._charset);\n\t      }\n\t      self._pos = response.length;\n\t    }\n\t    break\n\t  case 'arraybuffer':\n\t    if (xhr.readyState !== rStates.DONE || !xhr.response)\n\t      break\n\t    response = xhr.response;\n\t    self.push(new Buffer(new Uint8Array(response)));\n\t    break\n\t  case 'moz-chunked-arraybuffer': // take whole\n\t    response = xhr.response;\n\t    if (xhr.readyState !== rStates.LOADING || !response)\n\t      break\n\t    self.push(new Buffer(new Uint8Array(response)));\n\t    break\n\t  case 'ms-stream':\n\t    response = xhr.response;\n\t    if (xhr.readyState !== rStates.LOADING)\n\t      break\n\t    var reader = new global$1.MSStreamReader();\n\t    reader.onprogress = function() {\n\t      if (reader.result.byteLength > self._pos) {\n\t        self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));\n\t        self._pos = reader.result.byteLength;\n\t      }\n\t    };\n\t    reader.onload = function() {\n\t      self.push(null);\n\t    };\n\t      // reader.onerror = ??? // TODO: this\n\t    reader.readAsArrayBuffer(response);\n\t    break\n\t  }\n\n\t  // The ms-stream case handles end separately in reader.onload()\n\t  if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t    self.push(null);\n\t  }\n\t};\n\n\t// from https://github.com/jhiesey/to-arraybuffer/blob/6502d9850e70ba7935a7df4ad86b358fc216f9f0/index.js\n\n\tfunction toArrayBuffer (buf) {\n\t  // If the buffer is backed by a Uint8Array, a faster version will work\n\t  if (buf instanceof Uint8Array) {\n\t    // If the buffer isn't a subarray, return the underlying ArrayBuffer\n\t    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n\t      return buf.buffer\n\t    } else if (typeof buf.buffer.slice === 'function') {\n\t      // Otherwise we need to get a proper copy\n\t      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)\n\t    }\n\t  }\n\n\t  if (isBuffer(buf)) {\n\t    // This is the slow version that will work with any Buffer\n\t    // implementation (even in old browsers)\n\t    var arrayCopy = new Uint8Array(buf.length);\n\t    var len = buf.length;\n\t    for (var i = 0; i < len; i++) {\n\t      arrayCopy[i] = buf[i];\n\t    }\n\t    return arrayCopy.buffer\n\t  } else {\n\t    throw new Error('Argument must be a Buffer')\n\t  }\n\t}\n\n\tfunction decideMode(preferBinary, useFetch) {\n\t  if (hasFetch && useFetch) {\n\t    return 'fetch'\n\t  } else if (mozchunkedarraybuffer) {\n\t    return 'moz-chunked-arraybuffer'\n\t  } else if (msstream) {\n\t    return 'ms-stream'\n\t  } else if (arraybuffer && preferBinary) {\n\t    return 'arraybuffer'\n\t  } else if (vbArray && preferBinary) {\n\t    return 'text:vbarray'\n\t  } else {\n\t    return 'text'\n\t  }\n\t}\n\n\tfunction ClientRequest(opts) {\n\t  var self = this;\n\t  Writable.call(self);\n\n\t  self._opts = opts;\n\t  self._body = [];\n\t  self._headers = {};\n\t  if (opts.auth)\n\t    self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));\n\t  Object.keys(opts.headers).forEach(function(name) {\n\t    self.setHeader(name, opts.headers[name]);\n\t  });\n\n\t  var preferBinary;\n\t  var useFetch = true;\n\t  if (opts.mode === 'disable-fetch') {\n\t    // If the use of XHR should be preferred and includes preserving the 'content-type' header\n\t    useFetch = false;\n\t    preferBinary = true;\n\t  } else if (opts.mode === 'prefer-streaming') {\n\t    // If streaming is a high priority but binary compatibility and\n\t    // the accuracy of the 'content-type' header aren't\n\t    preferBinary = false;\n\t  } else if (opts.mode === 'allow-wrong-content-type') {\n\t    // If streaming is more important than preserving the 'content-type' header\n\t    preferBinary = !overrideMimeType;\n\t  } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t    // Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t    preferBinary = true;\n\t  } else {\n\t    throw new Error('Invalid value for opts.mode')\n\t  }\n\t  self._mode = decideMode(preferBinary, useFetch);\n\n\t  self.on('finish', function() {\n\t    self._onFinish();\n\t  });\n\t}\n\n\tinherits(ClientRequest, Writable);\n\t// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\n\tvar unsafeHeaders = [\n\t  'accept-charset',\n\t  'accept-encoding',\n\t  'access-control-request-headers',\n\t  'access-control-request-method',\n\t  'connection',\n\t  'content-length',\n\t  'cookie',\n\t  'cookie2',\n\t  'date',\n\t  'dnt',\n\t  'expect',\n\t  'host',\n\t  'keep-alive',\n\t  'origin',\n\t  'referer',\n\t  'te',\n\t  'trailer',\n\t  'transfer-encoding',\n\t  'upgrade',\n\t  'user-agent',\n\t  'via'\n\t];\n\tClientRequest.prototype.setHeader = function(name, value) {\n\t  var self = this;\n\t  var lowerName = name.toLowerCase();\n\t    // This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t    // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t    // http-browserify did it, so I will too.\n\t  if (unsafeHeaders.indexOf(lowerName) !== -1)\n\t    return\n\n\t  self._headers[lowerName] = {\n\t    name: name,\n\t    value: value\n\t  };\n\t};\n\n\tClientRequest.prototype.getHeader = function(name) {\n\t  var self = this;\n\t  return self._headers[name.toLowerCase()].value\n\t};\n\n\tClientRequest.prototype.removeHeader = function(name) {\n\t  var self = this;\n\t  delete self._headers[name.toLowerCase()];\n\t};\n\n\tClientRequest.prototype._onFinish = function() {\n\t  var self = this;\n\n\t  if (self._destroyed)\n\t    return\n\t  var opts = self._opts;\n\n\t  var headersObj = self._headers;\n\t  var body;\n\t  if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n\t    if (blobConstructor()) {\n\t      body = new global$1.Blob(self._body.map(function(buffer) {\n\t        return toArrayBuffer(buffer)\n\t      }), {\n\t        type: (headersObj['content-type'] || {}).value || ''\n\t      });\n\t    } else {\n\t      // get utf8 string\n\t      body = Buffer.concat(self._body).toString();\n\t    }\n\t  }\n\n\t  if (self._mode === 'fetch') {\n\t    var headers = Object.keys(headersObj).map(function(name) {\n\t      return [headersObj[name].name, headersObj[name].value]\n\t    });\n\n\t    global$1.fetch(self._opts.url, {\n\t      method: self._opts.method,\n\t      headers: headers,\n\t      body: body,\n\t      mode: 'cors',\n\t      credentials: opts.withCredentials ? 'include' : 'same-origin'\n\t    }).then(function(response) {\n\t      self._fetchResponse = response;\n\t      self._connect();\n\t    }, function(reason) {\n\t      self.emit('error', reason);\n\t    });\n\t  } else {\n\t    var xhr = self._xhr = new global$1.XMLHttpRequest();\n\t    try {\n\t      xhr.open(self._opts.method, self._opts.url, true);\n\t    } catch (err) {\n\t      browser$1.nextTick(function() {\n\t        self.emit('error', err);\n\t      });\n\t      return\n\t    }\n\n\t    // Can't set responseType on really old browsers\n\t    if ('responseType' in xhr)\n\t      xhr.responseType = self._mode.split(':')[0];\n\n\t    if ('withCredentials' in xhr)\n\t      xhr.withCredentials = !!opts.withCredentials;\n\n\t    if (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t      xhr.overrideMimeType('text/plain; charset=x-user-defined');\n\n\t    Object.keys(headersObj).forEach(function(name) {\n\t      xhr.setRequestHeader(headersObj[name].name, headersObj[name].value);\n\t    });\n\n\t    self._response = null;\n\t    xhr.onreadystatechange = function() {\n\t      switch (xhr.readyState) {\n\t      case rStates.LOADING:\n\t      case rStates.DONE:\n\t        self._onXHRProgress();\n\t        break\n\t      }\n\t    };\n\t      // Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t      // in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t    if (self._mode === 'moz-chunked-arraybuffer') {\n\t      xhr.onprogress = function() {\n\t        self._onXHRProgress();\n\t      };\n\t    }\n\n\t    xhr.onerror = function() {\n\t      if (self._destroyed)\n\t        return\n\t      self.emit('error', new Error('XHR error'));\n\t    };\n\n\t    try {\n\t      xhr.send(body);\n\t    } catch (err) {\n\t      browser$1.nextTick(function() {\n\t        self.emit('error', err);\n\t      });\n\t      return\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Checks if xhr.status is readable and non-zero, indicating no error.\n\t * Even though the spec says it should be available in readyState 3,\n\t * accessing it throws an exception in IE8\n\t */\n\tfunction statusValid(xhr) {\n\t  try {\n\t    var status = xhr.status;\n\t    return (status !== null && status !== 0)\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\n\tClientRequest.prototype._onXHRProgress = function() {\n\t  var self = this;\n\n\t  if (!statusValid(self._xhr) || self._destroyed)\n\t    return\n\n\t  if (!self._response)\n\t    self._connect();\n\n\t  self._response._onXHRProgress();\n\t};\n\n\tClientRequest.prototype._connect = function() {\n\t  var self = this;\n\n\t  if (self._destroyed)\n\t    return\n\n\t  self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode);\n\t  self.emit('response', self._response);\n\t};\n\n\tClientRequest.prototype._write = function(chunk, encoding, cb) {\n\t  var self = this;\n\n\t  self._body.push(chunk);\n\t  cb();\n\t};\n\n\tClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {\n\t  var self = this;\n\t  self._destroyed = true;\n\t  if (self._response)\n\t    self._response._destroyed = true;\n\t  if (self._xhr)\n\t    self._xhr.abort();\n\t    // Currently, there isn't a way to truly abort a fetch.\n\t    // If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27\n\t};\n\n\tClientRequest.prototype.end = function(data, encoding, cb) {\n\t  var self = this;\n\t  if (typeof data === 'function') {\n\t    cb = data;\n\t    data = undefined;\n\t  }\n\n\t  Writable.prototype.end.call(self, data, encoding, cb);\n\t};\n\n\tClientRequest.prototype.flushHeaders = function() {};\n\tClientRequest.prototype.setTimeout = function() {};\n\tClientRequest.prototype.setNoDelay = function() {};\n\tClientRequest.prototype.setSocketKeepAlive = function() {};\n\n\t/*! https://mths.be/punycode v1.4.1 by @mathias */\n\n\n\t/** Highest positive signed 32-bit float value */\n\tvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tvar base = 36;\n\tvar tMin = 1;\n\tvar tMax = 26;\n\tvar skew = 38;\n\tvar damp = 700;\n\tvar initialBias = 72;\n\tvar initialN = 128; // 0x80\n\tvar delimiter = '-'; // '\\x2D'\n\tvar regexNonASCII = /[^\\x20-\\x7E]/; // unprintable ASCII chars + non-ASCII chars\n\tvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n\t/** Error messages */\n\tvar errors = {\n\t  'overflow': 'Overflow: input needs wider integers to process',\n\t  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t  'invalid-input': 'Invalid input'\n\t};\n\n\t/** Convenience shortcuts */\n\tvar baseMinusTMin = base - tMin;\n\tvar floor = Math.floor;\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t  throw new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map$1(array, fn) {\n\t  var length = array.length;\n\t  var result = [];\n\t  while (length--) {\n\t    result[length] = fn(array[length]);\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t  var parts = string.split('@');\n\t  var result = '';\n\t  if (parts.length > 1) {\n\t    // In email addresses, only the domain name should be punycoded. Leave\n\t    // the local part (i.e. everything up to `@`) intact.\n\t    result = parts[0] + '@';\n\t    string = parts[1];\n\t  }\n\t  // Avoid `split(regex)` for IE8 compatibility. See #17.\n\t  string = string.replace(regexSeparators, '\\x2E');\n\t  var labels = string.split('.');\n\t  var encoded = map$1(labels, fn).join('.');\n\t  return result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t  var output = [],\n\t    counter = 0,\n\t    length = string.length,\n\t    value,\n\t    extra;\n\t  while (counter < length) {\n\t    value = string.charCodeAt(counter++);\n\t    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t      // high surrogate, and there is a next character\n\t      extra = string.charCodeAt(counter++);\n\t      if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t      } else {\n\t        // unmatched surrogate; only append this code unit, in case the next\n\t        // code unit is the high surrogate of a surrogate pair\n\t        output.push(value);\n\t        counter--;\n\t      }\n\t    } else {\n\t      output.push(value);\n\t    }\n\t  }\n\t  return output;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t  //  0..25 map to ASCII a..z or A..Z\n\t  // 26..35 map to ASCII 0..9\n\t  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t  var k = 0;\n\t  delta = firstTime ? floor(delta / damp) : delta >> 1;\n\t  delta += floor(delta / numPoints);\n\t  for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t    delta = floor(delta / baseMinusTMin);\n\t  }\n\t  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t  var n,\n\t    delta,\n\t    handledCPCount,\n\t    basicLength,\n\t    bias,\n\t    j,\n\t    m,\n\t    q,\n\t    k,\n\t    t,\n\t    currentValue,\n\t    output = [],\n\t    /** `inputLength` will hold the number of code points in `input`. */\n\t    inputLength,\n\t    /** Cached calculation results */\n\t    handledCPCountPlusOne,\n\t    baseMinusT,\n\t    qMinusT;\n\n\t  // Convert the input in UCS-2 to Unicode\n\t  input = ucs2decode(input);\n\n\t  // Cache the length\n\t  inputLength = input.length;\n\n\t  // Initialize the state\n\t  n = initialN;\n\t  delta = 0;\n\t  bias = initialBias;\n\n\t  // Handle the basic code points\n\t  for (j = 0; j < inputLength; ++j) {\n\t    currentValue = input[j];\n\t    if (currentValue < 0x80) {\n\t      output.push(stringFromCharCode(currentValue));\n\t    }\n\t  }\n\n\t  handledCPCount = basicLength = output.length;\n\n\t  // `handledCPCount` is the number of code points that have been handled;\n\t  // `basicLength` is the number of basic code points.\n\n\t  // Finish the basic string - if it is not empty - with a delimiter\n\t  if (basicLength) {\n\t    output.push(delimiter);\n\t  }\n\n\t  // Main encoding loop:\n\t  while (handledCPCount < inputLength) {\n\n\t    // All non-basic code points < n have been handled already. Find the next\n\t    // larger one:\n\t    for (m = maxInt, j = 0; j < inputLength; ++j) {\n\t      currentValue = input[j];\n\t      if (currentValue >= n && currentValue < m) {\n\t        m = currentValue;\n\t      }\n\t    }\n\n\t    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t    // but guard against overflow\n\t    handledCPCountPlusOne = handledCPCount + 1;\n\t    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t      error('overflow');\n\t    }\n\n\t    delta += (m - n) * handledCPCountPlusOne;\n\t    n = m;\n\n\t    for (j = 0; j < inputLength; ++j) {\n\t      currentValue = input[j];\n\n\t      if (currentValue < n && ++delta > maxInt) {\n\t        error('overflow');\n\t      }\n\n\t      if (currentValue == n) {\n\t        // Represent delta as a generalized variable-length integer\n\t        for (q = delta, k = base; /* no condition */ ; k += base) {\n\t          t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t          if (q < t) {\n\t            break;\n\t          }\n\t          qMinusT = q - t;\n\t          baseMinusT = base - t;\n\t          output.push(\n\t            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t          );\n\t          q = floor(qMinusT / baseMinusT);\n\t        }\n\n\t        output.push(stringFromCharCode(digitToBasic(q, 0)));\n\t        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t        delta = 0;\n\t        ++handledCPCount;\n\t      }\n\t    }\n\n\t    ++delta;\n\t    ++n;\n\n\t  }\n\t  return output.join('');\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t  return mapDomain(input, function(string) {\n\t    return regexNonASCII.test(string) ?\n\t      'xn--' + encode(string) :\n\t      string;\n\t  });\n\t}\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t// If obj.hasOwnProperty has been overridden, then calling\n\t// obj.hasOwnProperty(prop) will break.\n\t// See: https://github.com/joyent/node/issues/1707\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\tvar isArray = Array.isArray || function (xs) {\n\t  return Object.prototype.toString.call(xs) === '[object Array]';\n\t};\n\tfunction stringifyPrimitive(v) {\n\t  switch (typeof v) {\n\t    case 'string':\n\t      return v;\n\n\t    case 'boolean':\n\t      return v ? 'true' : 'false';\n\n\t    case 'number':\n\t      return isFinite(v) ? v : '';\n\n\t    default:\n\t      return '';\n\t  }\n\t}\n\n\tfunction stringify (obj, sep, eq, name) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  if (obj === null) {\n\t    obj = undefined;\n\t  }\n\n\t  if (typeof obj === 'object') {\n\t    return map(objectKeys(obj), function(k) {\n\t      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\t      if (isArray(obj[k])) {\n\t        return map(obj[k], function(v) {\n\t          return ks + encodeURIComponent(stringifyPrimitive(v));\n\t        }).join(sep);\n\t      } else {\n\t        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n\t      }\n\t    }).join(sep);\n\n\t  }\n\n\t  if (!name) return '';\n\t  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n\t         encodeURIComponent(stringifyPrimitive(obj));\n\t}\n\tfunction map (xs, f) {\n\t  if (xs.map) return xs.map(f);\n\t  var res = [];\n\t  for (var i = 0; i < xs.length; i++) {\n\t    res.push(f(xs[i], i));\n\t  }\n\t  return res;\n\t}\n\n\tvar objectKeys = Object.keys || function (obj) {\n\t  var res = [];\n\t  for (var key in obj) {\n\t    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n\t  }\n\t  return res;\n\t};\n\n\tfunction parse$1(qs, sep, eq, options) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  var obj = {};\n\n\t  if (typeof qs !== 'string' || qs.length === 0) {\n\t    return obj;\n\t  }\n\n\t  var regexp = /\\+/g;\n\t  qs = qs.split(sep);\n\n\t  var maxKeys = 1000;\n\t  if (options && typeof options.maxKeys === 'number') {\n\t    maxKeys = options.maxKeys;\n\t  }\n\n\t  var len = qs.length;\n\t  // maxKeys <= 0 means that we should not limit keys count\n\t  if (maxKeys > 0 && len > maxKeys) {\n\t    len = maxKeys;\n\t  }\n\n\t  for (var i = 0; i < len; ++i) {\n\t    var x = qs[i].replace(regexp, '%20'),\n\t        idx = x.indexOf(eq),\n\t        kstr, vstr, k, v;\n\n\t    if (idx >= 0) {\n\t      kstr = x.substr(0, idx);\n\t      vstr = x.substr(idx + 1);\n\t    } else {\n\t      kstr = x;\n\t      vstr = '';\n\t    }\n\n\t    k = decodeURIComponent(kstr);\n\t    v = decodeURIComponent(vstr);\n\n\t    if (!hasOwnProperty(obj, k)) {\n\t      obj[k] = v;\n\t    } else if (isArray(obj[k])) {\n\t      obj[k].push(v);\n\t    } else {\n\t      obj[k] = [obj[k], v];\n\t    }\n\t  }\n\n\t  return obj;\n\t}\n\n\t// WHATWG API\n\tglobal$1.URL;\n\tglobal$1.URLSearchParams;\n\tfunction Url() {\n\t  this.protocol = null;\n\t  this.slashes = null;\n\t  this.auth = null;\n\t  this.host = null;\n\t  this.port = null;\n\t  this.hostname = null;\n\t  this.hash = null;\n\t  this.search = null;\n\t  this.query = null;\n\t  this.pathname = null;\n\t  this.path = null;\n\t  this.href = null;\n\t}\n\n\t// Reference: RFC 3986, RFC 1808, RFC 2396\n\n\t// define these here so at least they only have to be\n\t// compiled once on the first module load.\n\tvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n\t  portPattern = /:[0-9]*$/,\n\n\t  // Special case for a simple path URL\n\t  simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n\t  // RFC 2396: characters reserved for delimiting URLs.\n\t  // We actually just auto-escape these.\n\t  delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n\t  // RFC 2396: characters not allowed for various reasons.\n\t  unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n\t  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n\t  autoEscape = ['\\''].concat(unwise),\n\t  // Characters that are never ever allowed in a hostname.\n\t  // Note that any invalid chars are also handled, but these\n\t  // are the ones that are *expected* to be seen, so we fast-path\n\t  // them.\n\t  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n\t  hostEndingChars = ['/', '?', '#'],\n\t  hostnameMaxLen = 255,\n\t  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n\t  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n\t  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n\t  unsafeProtocol = {\n\t    'javascript': true,\n\t    'javascript:': true\n\t  },\n\t  // protocols that never have a hostname.\n\t  hostlessProtocol = {\n\t    'javascript': true,\n\t    'javascript:': true\n\t  },\n\t  // protocols that always contain a // bit.\n\t  slashedProtocol = {\n\t    'http': true,\n\t    'https': true,\n\t    'ftp': true,\n\t    'gopher': true,\n\t    'file': true,\n\t    'http:': true,\n\t    'https:': true,\n\t    'ftp:': true,\n\t    'gopher:': true,\n\t    'file:': true\n\t  };\n\n\tfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n\t  if (url && isObject(url) && url instanceof Url) return url;\n\n\t  var u = new Url;\n\t  u.parse(url, parseQueryString, slashesDenoteHost);\n\t  return u;\n\t}\n\tUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n\t  return parse(this, url, parseQueryString, slashesDenoteHost);\n\t};\n\n\tfunction parse(self, url, parseQueryString, slashesDenoteHost) {\n\t  if (!isString(url)) {\n\t    throw new TypeError('Parameter \\'url\\' must be a string, not ' + typeof url);\n\t  }\n\n\t  // Copy chrome, IE, opera backslash-handling behavior.\n\t  // Back slashes before the query string get converted to forward slashes\n\t  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n\t  var queryIndex = url.indexOf('?'),\n\t    splitter =\n\t    (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n\t    uSplit = url.split(splitter),\n\t    slashRegex = /\\\\/g;\n\t  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n\t  url = uSplit.join(splitter);\n\n\t  var rest = url;\n\n\t  // trim before proceeding.\n\t  // This is to support parse stuff like \"  http://foo.com  \\n\"\n\t  rest = rest.trim();\n\n\t  if (!slashesDenoteHost && url.split('#').length === 1) {\n\t    // Try fast path regexp\n\t    var simplePath = simplePathPattern.exec(rest);\n\t    if (simplePath) {\n\t      self.path = rest;\n\t      self.href = rest;\n\t      self.pathname = simplePath[1];\n\t      if (simplePath[2]) {\n\t        self.search = simplePath[2];\n\t        if (parseQueryString) {\n\t          self.query = parse$1(self.search.substr(1));\n\t        } else {\n\t          self.query = self.search.substr(1);\n\t        }\n\t      } else if (parseQueryString) {\n\t        self.search = '';\n\t        self.query = {};\n\t      }\n\t      return self;\n\t    }\n\t  }\n\n\t  var proto = protocolPattern.exec(rest);\n\t  if (proto) {\n\t    proto = proto[0];\n\t    var lowerProto = proto.toLowerCase();\n\t    self.protocol = lowerProto;\n\t    rest = rest.substr(proto.length);\n\t  }\n\n\t  // figure out if it's got a host\n\t  // user@server is *always* interpreted as a hostname, and url\n\t  // resolution will treat //foo/bar as host=foo,path=bar because that's\n\t  // how the browser resolves relative URLs.\n\t  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n\t    var slashes = rest.substr(0, 2) === '//';\n\t    if (slashes && !(proto && hostlessProtocol[proto])) {\n\t      rest = rest.substr(2);\n\t      self.slashes = true;\n\t    }\n\t  }\n\t  var i, hec, l, p;\n\t  if (!hostlessProtocol[proto] &&\n\t    (slashes || (proto && !slashedProtocol[proto]))) {\n\n\t    // there's a hostname.\n\t    // the first instance of /, ?, ;, or # ends the host.\n\t    //\n\t    // If there is an @ in the hostname, then non-host chars *are* allowed\n\t    // to the left of the last @ sign, unless some host-ending character\n\t    // comes *before* the @-sign.\n\t    // URLs are obnoxious.\n\t    //\n\t    // ex:\n\t    // http://a@b@c/ => user:a@b host:c\n\t    // http://a@b?@c => user:a host:c path:/?@c\n\n\t    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n\t    // Review our test case against browsers more comprehensively.\n\n\t    // find the first instance of any hostEndingChars\n\t    var hostEnd = -1;\n\t    for (i = 0; i < hostEndingChars.length; i++) {\n\t      hec = rest.indexOf(hostEndingChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n\t        hostEnd = hec;\n\t    }\n\n\t    // at this point, either we have an explicit point where the\n\t    // auth portion cannot go past, or the last @ char is the decider.\n\t    var auth, atSign;\n\t    if (hostEnd === -1) {\n\t      // atSign can be anywhere.\n\t      atSign = rest.lastIndexOf('@');\n\t    } else {\n\t      // atSign must be in auth portion.\n\t      // http://a@b/c@d => host:b auth:a path:/c@d\n\t      atSign = rest.lastIndexOf('@', hostEnd);\n\t    }\n\n\t    // Now we have a portion which is definitely the auth.\n\t    // Pull that off.\n\t    if (atSign !== -1) {\n\t      auth = rest.slice(0, atSign);\n\t      rest = rest.slice(atSign + 1);\n\t      self.auth = decodeURIComponent(auth);\n\t    }\n\n\t    // the host is the remaining to the left of the first non-host char\n\t    hostEnd = -1;\n\t    for (i = 0; i < nonHostChars.length; i++) {\n\t      hec = rest.indexOf(nonHostChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n\t        hostEnd = hec;\n\t    }\n\t    // if we still have not hit it, then the entire thing is a host.\n\t    if (hostEnd === -1)\n\t      hostEnd = rest.length;\n\n\t    self.host = rest.slice(0, hostEnd);\n\t    rest = rest.slice(hostEnd);\n\n\t    // pull out port.\n\t    parseHost(self);\n\n\t    // we've indicated that there is a hostname,\n\t    // so even if it's empty, it has to be present.\n\t    self.hostname = self.hostname || '';\n\n\t    // if hostname begins with [ and ends with ]\n\t    // assume that it's an IPv6 address.\n\t    var ipv6Hostname = self.hostname[0] === '[' &&\n\t      self.hostname[self.hostname.length - 1] === ']';\n\n\t    // validate a little.\n\t    if (!ipv6Hostname) {\n\t      var hostparts = self.hostname.split(/\\./);\n\t      for (i = 0, l = hostparts.length; i < l; i++) {\n\t        var part = hostparts[i];\n\t        if (!part) continue;\n\t        if (!part.match(hostnamePartPattern)) {\n\t          var newpart = '';\n\t          for (var j = 0, k = part.length; j < k; j++) {\n\t            if (part.charCodeAt(j) > 127) {\n\t              // we replace non-ASCII char with a temporary placeholder\n\t              // we need this to make sure size of hostname is not\n\t              // broken by replacing non-ASCII by nothing\n\t              newpart += 'x';\n\t            } else {\n\t              newpart += part[j];\n\t            }\n\t          }\n\t          // we test again with ASCII char only\n\t          if (!newpart.match(hostnamePartPattern)) {\n\t            var validParts = hostparts.slice(0, i);\n\t            var notHost = hostparts.slice(i + 1);\n\t            var bit = part.match(hostnamePartStart);\n\t            if (bit) {\n\t              validParts.push(bit[1]);\n\t              notHost.unshift(bit[2]);\n\t            }\n\t            if (notHost.length) {\n\t              rest = '/' + notHost.join('.') + rest;\n\t            }\n\t            self.hostname = validParts.join('.');\n\t            break;\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    if (self.hostname.length > hostnameMaxLen) {\n\t      self.hostname = '';\n\t    } else {\n\t      // hostnames are always lower case.\n\t      self.hostname = self.hostname.toLowerCase();\n\t    }\n\n\t    if (!ipv6Hostname) {\n\t      // IDNA Support: Returns a punycoded representation of \"domain\".\n\t      // It only converts parts of the domain name that\n\t      // have non-ASCII characters, i.e. it doesn't matter if\n\t      // you call it with a domain that already is ASCII-only.\n\t      self.hostname = toASCII(self.hostname);\n\t    }\n\n\t    p = self.port ? ':' + self.port : '';\n\t    var h = self.hostname || '';\n\t    self.host = h + p;\n\t    self.href += self.host;\n\n\t    // strip [ and ] from the hostname\n\t    // the host field still retains them, though\n\t    if (ipv6Hostname) {\n\t      self.hostname = self.hostname.substr(1, self.hostname.length - 2);\n\t      if (rest[0] !== '/') {\n\t        rest = '/' + rest;\n\t      }\n\t    }\n\t  }\n\n\t  // now rest is set to the post-host stuff.\n\t  // chop off any delim chars.\n\t  if (!unsafeProtocol[lowerProto]) {\n\n\t    // First, make 100% sure that any \"autoEscape\" chars get\n\t    // escaped, even if encodeURIComponent doesn't think they\n\t    // need to be.\n\t    for (i = 0, l = autoEscape.length; i < l; i++) {\n\t      var ae = autoEscape[i];\n\t      if (rest.indexOf(ae) === -1)\n\t        continue;\n\t      var esc = encodeURIComponent(ae);\n\t      if (esc === ae) {\n\t        esc = escape(ae);\n\t      }\n\t      rest = rest.split(ae).join(esc);\n\t    }\n\t  }\n\n\n\t  // chop off from the tail first.\n\t  var hash = rest.indexOf('#');\n\t  if (hash !== -1) {\n\t    // got a fragment string.\n\t    self.hash = rest.substr(hash);\n\t    rest = rest.slice(0, hash);\n\t  }\n\t  var qm = rest.indexOf('?');\n\t  if (qm !== -1) {\n\t    self.search = rest.substr(qm);\n\t    self.query = rest.substr(qm + 1);\n\t    if (parseQueryString) {\n\t      self.query = parse$1(self.query);\n\t    }\n\t    rest = rest.slice(0, qm);\n\t  } else if (parseQueryString) {\n\t    // no query string, but parseQueryString still requested\n\t    self.search = '';\n\t    self.query = {};\n\t  }\n\t  if (rest) self.pathname = rest;\n\t  if (slashedProtocol[lowerProto] &&\n\t    self.hostname && !self.pathname) {\n\t    self.pathname = '/';\n\t  }\n\n\t  //to support http.request\n\t  if (self.pathname || self.search) {\n\t    p = self.pathname || '';\n\t    var s = self.search || '';\n\t    self.path = p + s;\n\t  }\n\n\t  // finally, reconstruct the href based on what has been validated.\n\t  self.href = format(self);\n\t  return self;\n\t}\n\n\tfunction format(self) {\n\t  var auth = self.auth || '';\n\t  if (auth) {\n\t    auth = encodeURIComponent(auth);\n\t    auth = auth.replace(/%3A/i, ':');\n\t    auth += '@';\n\t  }\n\n\t  var protocol = self.protocol || '',\n\t    pathname = self.pathname || '',\n\t    hash = self.hash || '',\n\t    host = false,\n\t    query = '';\n\n\t  if (self.host) {\n\t    host = auth + self.host;\n\t  } else if (self.hostname) {\n\t    host = auth + (self.hostname.indexOf(':') === -1 ?\n\t      self.hostname :\n\t      '[' + this.hostname + ']');\n\t    if (self.port) {\n\t      host += ':' + self.port;\n\t    }\n\t  }\n\n\t  if (self.query &&\n\t    isObject(self.query) &&\n\t    Object.keys(self.query).length) {\n\t    query = stringify(self.query);\n\t  }\n\n\t  var search = self.search || (query && ('?' + query)) || '';\n\n\t  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n\t  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n\t  // unless they had them to begin with.\n\t  if (self.slashes ||\n\t    (!protocol || slashedProtocol[protocol]) && host !== false) {\n\t    host = '//' + (host || '');\n\t    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n\t  } else if (!host) {\n\t    host = '';\n\t  }\n\n\t  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n\t  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n\t  pathname = pathname.replace(/[?#]/g, function(match) {\n\t    return encodeURIComponent(match);\n\t  });\n\t  search = search.replace('#', '%23');\n\n\t  return protocol + host + pathname + search + hash;\n\t}\n\n\tUrl.prototype.format = function() {\n\t  return format(this);\n\t};\n\n\tUrl.prototype.resolve = function(relative) {\n\t  return this.resolveObject(urlParse(relative, false, true)).format();\n\t};\n\n\tUrl.prototype.resolveObject = function(relative) {\n\t  if (isString(relative)) {\n\t    var rel = new Url();\n\t    rel.parse(relative, false, true);\n\t    relative = rel;\n\t  }\n\n\t  var result = new Url();\n\t  var tkeys = Object.keys(this);\n\t  for (var tk = 0; tk < tkeys.length; tk++) {\n\t    var tkey = tkeys[tk];\n\t    result[tkey] = this[tkey];\n\t  }\n\n\t  // hash is always overridden, no matter what.\n\t  // even href=\"\" will remove it.\n\t  result.hash = relative.hash;\n\n\t  // if the relative url is empty, then there's nothing left to do here.\n\t  if (relative.href === '') {\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\n\t  // hrefs like //foo/bar always cut to the protocol.\n\t  if (relative.slashes && !relative.protocol) {\n\t    // take everything except the protocol from relative\n\t    var rkeys = Object.keys(relative);\n\t    for (var rk = 0; rk < rkeys.length; rk++) {\n\t      var rkey = rkeys[rk];\n\t      if (rkey !== 'protocol')\n\t        result[rkey] = relative[rkey];\n\t    }\n\n\t    //urlParse appends trailing / to urls like http://www.example.com\n\t    if (slashedProtocol[result.protocol] &&\n\t      result.hostname && !result.pathname) {\n\t      result.path = result.pathname = '/';\n\t    }\n\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t  var relPath;\n\t  if (relative.protocol && relative.protocol !== result.protocol) {\n\t    // if it's a known url protocol, then changing\n\t    // the protocol does weird things\n\t    // first, if it's not file:, then we MUST have a host,\n\t    // and if there was a path\n\t    // to begin with, then we MUST have a path.\n\t    // if it is file:, then the host is dropped,\n\t    // because that's known to be hostless.\n\t    // anything else is assumed to be absolute.\n\t    if (!slashedProtocol[relative.protocol]) {\n\t      var keys = Object.keys(relative);\n\t      for (var v = 0; v < keys.length; v++) {\n\t        var k = keys[v];\n\t        result[k] = relative[k];\n\t      }\n\t      result.href = result.format();\n\t      return result;\n\t    }\n\n\t    result.protocol = relative.protocol;\n\t    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n\t      relPath = (relative.pathname || '').split('/');\n\t      while (relPath.length && !(relative.host = relPath.shift()));\n\t      if (!relative.host) relative.host = '';\n\t      if (!relative.hostname) relative.hostname = '';\n\t      if (relPath[0] !== '') relPath.unshift('');\n\t      if (relPath.length < 2) relPath.unshift('');\n\t      result.pathname = relPath.join('/');\n\t    } else {\n\t      result.pathname = relative.pathname;\n\t    }\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    result.host = relative.host || '';\n\t    result.auth = relative.auth;\n\t    result.hostname = relative.hostname || relative.host;\n\t    result.port = relative.port;\n\t    // to support http.request\n\t    if (result.pathname || result.search) {\n\t      var p = result.pathname || '';\n\t      var s = result.search || '';\n\t      result.path = p + s;\n\t    }\n\t    result.slashes = result.slashes || relative.slashes;\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\n\t  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n\t    isRelAbs = (\n\t      relative.host ||\n\t      relative.pathname && relative.pathname.charAt(0) === '/'\n\t    ),\n\t    mustEndAbs = (isRelAbs || isSourceAbs ||\n\t      (result.host && relative.pathname)),\n\t    removeAllDots = mustEndAbs,\n\t    srcPath = result.pathname && result.pathname.split('/') || [],\n\t    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\t  relPath = relative.pathname && relative.pathname.split('/') || [];\n\t  // if the url is a non-slashed url, then relative\n\t  // links like ../.. should be able\n\t  // to crawl up to the hostname, as well.  This is strange.\n\t  // result.protocol has already been set by now.\n\t  // Later on, put the first path part into the host field.\n\t  if (psychotic) {\n\t    result.hostname = '';\n\t    result.port = null;\n\t    if (result.host) {\n\t      if (srcPath[0] === '') srcPath[0] = result.host;\n\t      else srcPath.unshift(result.host);\n\t    }\n\t    result.host = '';\n\t    if (relative.protocol) {\n\t      relative.hostname = null;\n\t      relative.port = null;\n\t      if (relative.host) {\n\t        if (relPath[0] === '') relPath[0] = relative.host;\n\t        else relPath.unshift(relative.host);\n\t      }\n\t      relative.host = null;\n\t    }\n\t    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n\t  }\n\t  var authInHost;\n\t  if (isRelAbs) {\n\t    // it's absolute.\n\t    result.host = (relative.host || relative.host === '') ?\n\t      relative.host : result.host;\n\t    result.hostname = (relative.hostname || relative.hostname === '') ?\n\t      relative.hostname : result.hostname;\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    srcPath = relPath;\n\t    // fall through to the dot-handling below.\n\t  } else if (relPath.length) {\n\t    // it's relative\n\t    // throw away the existing file, and take the new path instead.\n\t    if (!srcPath) srcPath = [];\n\t    srcPath.pop();\n\t    srcPath = srcPath.concat(relPath);\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t  } else if (!isNullOrUndefined(relative.search)) {\n\t    // just pull out the search.\n\t    // like href='?foo'.\n\t    // Put this after the other two cases because it simplifies the booleans\n\t    if (psychotic) {\n\t      result.hostname = result.host = srcPath.shift();\n\t      //occationaly the auth can get stuck only in host\n\t      //this especially happens in cases like\n\t      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\t      authInHost = result.host && result.host.indexOf('@') > 0 ?\n\t        result.host.split('@') : false;\n\t      if (authInHost) {\n\t        result.auth = authInHost.shift();\n\t        result.host = result.hostname = authInHost.shift();\n\t      }\n\t    }\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    //to support http.request\n\t    if (!isNull(result.pathname) || !isNull(result.search)) {\n\t      result.path = (result.pathname ? result.pathname : '') +\n\t        (result.search ? result.search : '');\n\t    }\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\n\t  if (!srcPath.length) {\n\t    // no path at all.  easy.\n\t    // we've already handled the other stuff above.\n\t    result.pathname = null;\n\t    //to support http.request\n\t    if (result.search) {\n\t      result.path = '/' + result.search;\n\t    } else {\n\t      result.path = null;\n\t    }\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\n\t  // if a url ENDs in . or .., then it must get a trailing slash.\n\t  // however, if it ends in anything else non-slashy,\n\t  // then it must NOT get a trailing slash.\n\t  var last = srcPath.slice(-1)[0];\n\t  var hasTrailingSlash = (\n\t    (result.host || relative.host || srcPath.length > 1) &&\n\t    (last === '.' || last === '..') || last === '');\n\n\t  // strip single dots, resolve double dots to parent dir\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = srcPath.length; i >= 0; i--) {\n\t    last = srcPath[i];\n\t    if (last === '.') {\n\t      srcPath.splice(i, 1);\n\t    } else if (last === '..') {\n\t      srcPath.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      srcPath.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (!mustEndAbs && !removeAllDots) {\n\t    for (; up--; up) {\n\t      srcPath.unshift('..');\n\t    }\n\t  }\n\n\t  if (mustEndAbs && srcPath[0] !== '' &&\n\t    (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n\t    srcPath.unshift('');\n\t  }\n\n\t  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n\t    srcPath.push('');\n\t  }\n\n\t  var isAbsolute = srcPath[0] === '' ||\n\t    (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n\t  // put the host back\n\t  if (psychotic) {\n\t    result.hostname = result.host = isAbsolute ? '' :\n\t      srcPath.length ? srcPath.shift() : '';\n\t    //occationaly the auth can get stuck only in host\n\t    //this especially happens in cases like\n\t    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\t    authInHost = result.host && result.host.indexOf('@') > 0 ?\n\t      result.host.split('@') : false;\n\t    if (authInHost) {\n\t      result.auth = authInHost.shift();\n\t      result.host = result.hostname = authInHost.shift();\n\t    }\n\t  }\n\n\t  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n\t  if (mustEndAbs && !isAbsolute) {\n\t    srcPath.unshift('');\n\t  }\n\n\t  if (!srcPath.length) {\n\t    result.pathname = null;\n\t    result.path = null;\n\t  } else {\n\t    result.pathname = srcPath.join('/');\n\t  }\n\n\t  //to support request.http\n\t  if (!isNull(result.pathname) || !isNull(result.search)) {\n\t    result.path = (result.pathname ? result.pathname : '') +\n\t      (result.search ? result.search : '');\n\t  }\n\t  result.auth = relative.auth || result.auth;\n\t  result.slashes = result.slashes || relative.slashes;\n\t  result.href = result.format();\n\t  return result;\n\t};\n\n\tUrl.prototype.parseHost = function() {\n\t  return parseHost(this);\n\t};\n\n\tfunction parseHost(self) {\n\t  var host = self.host;\n\t  var port = portPattern.exec(host);\n\t  if (port) {\n\t    port = port[0];\n\t    if (port !== ':') {\n\t      self.port = port.substr(1);\n\t    }\n\t    host = host.substr(0, host.length - port.length);\n\t  }\n\t  if (host) self.hostname = host;\n\t}\n\n\tfunction request(opts, cb) {\n\t  if (typeof opts === 'string')\n\t    opts = urlParse(opts);\n\n\n\t  // Normally, the page is loaded from http or https, so not specifying a protocol\n\t  // will result in a (valid) protocol-relative url. However, this won't work if\n\t  // the protocol is something else, like 'file:'\n\t  var defaultProtocol = global$1.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';\n\n\t  var protocol = opts.protocol || defaultProtocol;\n\t  var host = opts.hostname || opts.host;\n\t  var port = opts.port;\n\t  var path = opts.path || '/';\n\n\t  // Necessary for IPv6 addresses\n\t  if (host && host.indexOf(':') !== -1)\n\t    host = '[' + host + ']';\n\n\t  // This may be a relative url. The browser should always be able to interpret it correctly.\n\t  opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path;\n\t  opts.method = (opts.method || 'GET').toUpperCase();\n\t  opts.headers = opts.headers || {};\n\n\t  // Also valid opts.auth, opts.mode\n\n\t  var req = new ClientRequest(opts);\n\t  if (cb)\n\t    req.on('response', cb);\n\t  return req\n\t}\n\n\tfunction get(opts, cb) {\n\t  var req = request(opts, cb);\n\t  req.end();\n\t  return req\n\t}\n\n\tfunction Agent() {}\n\tAgent.defaultMaxSockets = 4;\n\n\tvar METHODS = [\n\t  'CHECKOUT',\n\t  'CONNECT',\n\t  'COPY',\n\t  'DELETE',\n\t  'GET',\n\t  'HEAD',\n\t  'LOCK',\n\t  'M-SEARCH',\n\t  'MERGE',\n\t  'MKACTIVITY',\n\t  'MKCOL',\n\t  'MOVE',\n\t  'NOTIFY',\n\t  'OPTIONS',\n\t  'PATCH',\n\t  'POST',\n\t  'PROPFIND',\n\t  'PROPPATCH',\n\t  'PURGE',\n\t  'PUT',\n\t  'REPORT',\n\t  'SEARCH',\n\t  'SUBSCRIBE',\n\t  'TRACE',\n\t  'UNLOCK',\n\t  'UNSUBSCRIBE'\n\t];\n\tvar STATUS_CODES = {\n\t  100: 'Continue',\n\t  101: 'Switching Protocols',\n\t  102: 'Processing', // RFC 2518, obsoleted by RFC 4918\n\t  200: 'OK',\n\t  201: 'Created',\n\t  202: 'Accepted',\n\t  203: 'Non-Authoritative Information',\n\t  204: 'No Content',\n\t  205: 'Reset Content',\n\t  206: 'Partial Content',\n\t  207: 'Multi-Status', // RFC 4918\n\t  300: 'Multiple Choices',\n\t  301: 'Moved Permanently',\n\t  302: 'Moved Temporarily',\n\t  303: 'See Other',\n\t  304: 'Not Modified',\n\t  305: 'Use Proxy',\n\t  307: 'Temporary Redirect',\n\t  400: 'Bad Request',\n\t  401: 'Unauthorized',\n\t  402: 'Payment Required',\n\t  403: 'Forbidden',\n\t  404: 'Not Found',\n\t  405: 'Method Not Allowed',\n\t  406: 'Not Acceptable',\n\t  407: 'Proxy Authentication Required',\n\t  408: 'Request Time-out',\n\t  409: 'Conflict',\n\t  410: 'Gone',\n\t  411: 'Length Required',\n\t  412: 'Precondition Failed',\n\t  413: 'Request Entity Too Large',\n\t  414: 'Request-URI Too Large',\n\t  415: 'Unsupported Media Type',\n\t  416: 'Requested Range Not Satisfiable',\n\t  417: 'Expectation Failed',\n\t  418: 'I\\'m a teapot', // RFC 2324\n\t  422: 'Unprocessable Entity', // RFC 4918\n\t  423: 'Locked', // RFC 4918\n\t  424: 'Failed Dependency', // RFC 4918\n\t  425: 'Unordered Collection', // RFC 4918\n\t  426: 'Upgrade Required', // RFC 2817\n\t  428: 'Precondition Required', // RFC 6585\n\t  429: 'Too Many Requests', // RFC 6585\n\t  431: 'Request Header Fields Too Large', // RFC 6585\n\t  500: 'Internal Server Error',\n\t  501: 'Not Implemented',\n\t  502: 'Bad Gateway',\n\t  503: 'Service Unavailable',\n\t  504: 'Gateway Time-out',\n\t  505: 'HTTP Version Not Supported',\n\t  506: 'Variant Also Negotiates', // RFC 2295\n\t  507: 'Insufficient Storage', // RFC 4918\n\t  509: 'Bandwidth Limit Exceeded',\n\t  510: 'Not Extended', // RFC 2774\n\t  511: 'Network Authentication Required' // RFC 6585\n\t};\n\n\tvar _polyfillNode_https = {\n\t  request,\n\t  get,\n\t  Agent,\n\t  METHODS,\n\t  STATUS_CODES\n\t};\n\n\tvar _polyfillNode_https$1 = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tAgent: Agent,\n\t\tMETHODS: METHODS,\n\t\tSTATUS_CODES: STATUS_CODES,\n\t\tdefault: _polyfillNode_https,\n\t\tget: get,\n\t\trequest: request\n\t});\n\n\tvar require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_https$1);\n\n\tconst https$1 = require$$0;\n\n\tvar Requests$1 = function (param) {\n\t\tthis.host = param.host;\n\t\tthis.port = param.port;\n\t\tthis.pathPrefix = param.pathPrefix;\n\t};\n\n\tRequests$1.prototype.https_clickupapi_get = function (path, token) {\n\t\tconst option = {\n\t\t\thost: this.host,\n\t\t\tport: this.port,\n\t\t\tpath: this.pathPrefix + path,\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: token,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t};\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tconst req = https$1.request(option, function (res) {\n\t\t\t\tvar str = \"\";\n\t\t\t\tif (res.statusCode != 200) {\n\t\t\t\t\treject(res.statusCode);\n\t\t\t\t}\n\n\t\t\t\tres.on(\"data\", function (chunk) {\n\t\t\t\t\tstr += chunk;\n\t\t\t\t});\n\n\t\t\t\tres.on(\"end\", function () {\n\t\t\t\t\tresolve(JSON.parse(str));\n\t\t\t\t});\n\n\t\t\t\tres.on(\"error\", function (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treq.on(\"error\", function (err) {\n\t\t\t\treject(err);\n\t\t\t});\n\n\t\t\treq.end();\n\t\t});\n\t};\n\n\tRequests$1.prototype.https_clickupapi_post = function (path, data, token) {\n\t\tdata = JSON.stringify(data);\n\t\tconst option = {\n\t\t\thost: this.host,\n\t\t\tport: this.port,\n\t\t\tpath: this.pathPrefix + path,\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: token,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t};\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tconst req = https$1.request(option, function (res) {\n\t\t\t\tvar str = \"\";\n\t\t\t\tif (res.statusCode != 200) {\n\t\t\t\t\treject(res.statusCode);\n\t\t\t\t}\n\n\t\t\t\tres.on(\"data\", function (chunk) {\n\t\t\t\t\tstr += chunk;\n\t\t\t\t});\n\n\t\t\t\tres.on(\"end\", function () {\n\t\t\t\t\tresolve(JSON.parse(str));\n\t\t\t\t});\n\n\t\t\t\tres.on(\"error\", function (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treq.on(\"error\", function (err) {\n\t\t\t\treject(err);\n\t\t\t});\n\t\t\treq.write(data);\n\t\t\treq.end();\n\t\t});\n\t};\n\n\tRequests$1.prototype.https_clickupapi_put = function (path, data, token) {\n\t\tdata = JSON.stringify(data);\n\t\tconst option = {\n\t\t\thost: this.host,\n\t\t\tport: this.port,\n\t\t\tpath: this.pathPrefix + path,\n\t\t\tmethod: \"PUT\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: token,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t};\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tconst req = https$1.request(option, function (res) {\n\t\t\t\tvar str = \"\";\n\t\t\t\tif (res.statusCode != 200) {\n\t\t\t\t\treject(res.statusCode);\n\t\t\t\t}\n\n\t\t\t\tres.on(\"data\", function (chunk) {\n\t\t\t\t\tstr += chunk;\n\t\t\t\t});\n\n\t\t\t\tres.on(\"end\", function () {\n\t\t\t\t\tresolve(JSON.parse(str));\n\t\t\t\t});\n\n\t\t\t\tres.on(\"error\", function (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treq.on(\"error\", function (err) {\n\t\t\t\treject(err);\n\t\t\t});\n\t\t\treq.write(data);\n\t\t\treq.end();\n\t\t});\n\t};\n\n\tRequests$1.prototype.https_clickupapi_delete = function (path, token) {\n\t\tconst option = {\n\t\t\thost: this.host,\n\t\t\tport: this.port,\n\t\t\tpath: this.pathPrefix + path,\n\t\t\tmethod: \"DELETE\",\n\t\t\theaders: {\n\t\t\t\tAuthorization: token,\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t},\n\t\t};\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tconst req = https$1.request(option, function (res) {\n\t\t\t\tvar str = \"\";\n\t\t\t\tif (res.statusCode != 204) {\n\t\t\t\t\treject(res.statusCode);\n\t\t\t\t}\n\t\t\t\t// 204 should not return any data, but if it does, we'll parse it\n\t\t\t\tres.on(\"data\", function (chunk) {\n\t\t\t\t\tstr += chunk;\n\t\t\t\t});\n\n\t\t\t\tres.on(\"end\", function () {\n\t\t\t\t\tlet parsedJSON = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparsedJSON = JSON.parse(str);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// ignore the error for now\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(parsedJSON);\n\t\t\t\t});\n\n\t\t\t\tres.on(\"error\", function (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treq.on(\"error\", function (err) {\n\t\t\t\treject(err);\n\t\t\t});\n\t\t\treq.end();\n\t\t});\n\t};\n\n\tvar requests = Requests$1;\n\n\tvar Checklists$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a checklist in a task.\n\t * @param {String} task_id Task that receives the Checklist\n\t * @param {JSON} data Body request for the Checklist\n\t */\n\tChecklists$1.prototype.create_checklist = function (task_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/checklist`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Edit a checklist.\n\t * @param {String} checklist_id Checklist id to be updated\n\t * @param {JSON} data Body request for the update\n\t */\n\tChecklists$1.prototype.edit_checklist = function (checklist_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete checklist.\n\t * @param {String} checklist_id Checklist ID to delete\n\t */\n\tChecklists$1.prototype.delete_checklist = function (checklist_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create a checklist intem.\n\t * @param {String} checklist_id Checklist ID to create a item\n\t * @param {JSON} data Contenet of the item\n\t */\n\tChecklists$1.prototype.create_checklist_item = function (checklist_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}/checklist_item`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update an item from the checklist\n\t * @param {String} checklist_id Checklist ID that contains the item\n\t * @param {String} checklist_item_id Item to be updated\n\t * @param {JSON} data Update content\n\t */\n\tChecklists$1.prototype.edit_checklist_item = function (\n\t\tchecklist_id,\n\t\tchecklist_item_id,\n\t\tdata\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}/checklist_item/${checklist_item_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Deletes an item from the checklist\n\t * @param {String} checklist_id Checklist ID that contains the item\n\t * @param {String} checklist_item_id Item to be deleted\n\t */\n\tChecklists$1.prototype.delete_checklist_item = function (\n\t\tchecklist_id,\n\t\tchecklist_item_id\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}/checklist_item/${checklist_item_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Checklists_1 = Checklists$1;\n\n\t/**\n\t * Gennerate the query string parameters\n\t * @param {(JSON | String)} params - A JSON with all the parameters for the request. (path and query)\n\t * @param {String[]} required - List of required elements to be present on 'params'\n\t * @param {String[]} path_params - Parameters to be placed on path, removed from query string.\n\t * @returns {String} The encoded query string\n\t */\n\n\tvar params = function (params, required, path_params) {\n\t\tvar requiredCount = 0;\n\n\t\trequired.forEach(function(elem){\n\t\t\tif (params[elem] === undefined) {\n\t\t\t\tconsole.error(`Error: ${elem} required, see ClickUp documentation`);\n\t\t\t\trequiredCount++;\n\t\t\t}\n\t\t});\n\n\t\tif (requiredCount !== 0){\n\t\t\treturn;\n\t\t}\n\n\t\tvar paramsName = Object.keys(params);\n\t\tvar str = \"\";\n\t\tlet first = true;\n\n\t\tfor(let i in paramsName){\n\t\t\tif(first)\n\t\t\t\tstr += \"?\"; first = false;\n\t\t\tif(!path_params.includes(paramsName[i])) {\n\t\t\t\tvar param = params[paramsName[i]];\n\t\t\t\tif(typeof(param) == 'object') {\n\t\t\t\t\tfor(let e of param) {\n\t\t\t\t\t\tstr += `${paramsName[i]}[]=${encodeURI(e)}&`;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstr += `${paramsName[i]}=${encodeURI(param)}&`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstr = str.slice(0,-1);\n\n\t\treturn str;\n\t};\n\n\tconst genParams$5 = params;\n\n\tvar Comments$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Comment on a task\n\t * @param {String} task_id Tesk ID that will receive comment\n\t * @param {JSON} data Body request for the comment\n\t */\n\tComments$1.prototype.create_task_comment = function (task_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/comment`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Comment on a view\n\t * @param {String} view_id View ID that will receive commet\n\t * @param {JSON} data Body request for the comment\n\t */\n\tComments$1.prototype.create_view_comment = function (view_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/view/${view_id}/comment`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Comment on a list\n\t * @param {String} list_id List id that will receive comment\n\t * @param {JSON} data Body request for the comment\n\t */\n\tComments$1.prototype.create_list_comment = function (list_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/list/${list_id}/comment`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a comment\n\t * @param {String} comment_id Comment ID of the comment to be updated\n\t * @param {JSON} data Body request for the update\n\t */\n\tComments$1.prototype.update_comment = function (comment_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/comment/${comment_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a comment\n\t * @param {String} comment_id Comment ID to be deleted\n\t */\n\tComments$1.prototype.delete_comment = function (comment_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/comment/${comment_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * See all comment on a task\n\t * @param {String} task_id Task ID of the task to be consult\n\t */\n\tComments$1.prototype.get_task_comment = function (task_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/task/${task_id}/comment`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * See all comment on a view\n\t * @param {String} view_id View ID of the task to be consult\n\t */\n\tComments$1.prototype.get_view_comment = function (view_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/view/${view_id}/comment`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * See all comment on a List\n\t * @param {String} list_id View ID of the task to be consult\n\t */\n\tComments$1.prototype.get_list_comment = function (list_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/list/${list_id}/comment`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * View comments from a Chat view.\n\t * @param {String} view_id View ID of chat\n\t * @param {JSON} params Object with query parameters\n\t */\n\tComments$1.prototype.get_chat_view_comments = function (view_id, params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$5(params, [\"view_id\"], [\"view_id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/view/${view_id}/comment${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add a new comment to a Chat view.\n\t * @param {String} view_id View ID where new commend gona be created\n\t * @param {JSON} data Body request for the comment\n\t */\n\tComments$1.prototype.create_chat_view_comment = function (view_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${view_id}/comment`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Comments_1 = Comments$1;\n\n\tvar CustomFields$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Set the custom field value\n\t * @param {String} task_id Task ID that contemplates the custom field\n\t * @param {String} field_id Field ID to be set the value\n\t * @param {JSON} data Body request for the field\n\t */\n\tCustomFields$1.prototype.set_custom_field_value = function (\n\t\ttask_id,\n\t\tfield_id,\n\t\tdata\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/field/${field_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove a value from a custom field\n\t * @param {String} task_id Task ID that contemplates the custom field\n\t * @param {String} field_id Field ID to be removed\n\t */\n\tCustomFields$1.prototype.remove_custom_field_value = function (\n\t\ttask_id,\n\t\tfield_id\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}/field/${field_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Consult all custom field from a list\n\t * @param {String} list_id List ID to be consulted\n\t */\n\tCustomFields$1.prototype.get_accessible_custom_fields = function (list_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/list/${list_id}/field`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar CustomFields_1 = CustomFields$1;\n\n\tvar Dependencies$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Add dependency\n\t * @param {String} task_id Task ID to add dependency\n\t * @param {JSON} data Dependency content\n\t */\n\tDependencies$1.prototype.add_dependency = function (task_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/dependency`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a dependency\n\t * @param {String} task_id Task ID that receives dependencies\n\t * @param {String} depends_on Task ID\n\t * @param {String } dependency_of Task ID\n\t */\n\tDependencies$1.prototype.delete_dependency = function (\n\t\ttask_id,\n\t\tdepends_on,\n\t\tdependency_of\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}/dependency?depends_on=${depends_on}&dependency_of=${dependency_of}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add a link between two tasks\n\t * @param {String} task_id Task ID that recive the link\n\t * @param {String} links_to Task ID of the other task\n\t */\n\tDependencies$1.prototype.add_task_link = function (task_id, links_to) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/link/${links_to}`,\n\t\t\t\t\t{},\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove the link\n\t * @param {String} task_id Task ID that be remove the link\n\t * @param {String} links_to Task ID to be removed\n\t */\n\tDependencies$1.prototype.delete_task_link = function (task_id, links_to) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}/link/${links_to}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Dependencies_1 = Dependencies$1;\n\n\tvar Folders$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a folder.\n\t * @param {String} space_id Space ID where the folder how be created\n\t * @param {JSON} data Body request for the folder.\n\t */\n\tFolders$1.prototype.create_folder = function (space_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/space/${space_id}/folder`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a folder.\n\t * @param {String} folder_id Folder to be updated\n\t * @param {String} data Body request for the update\n\t */\n\tFolders$1.prototype.update_folder = function (folder_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/folder/${folder_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a folder.\n\t * @param {String} folder_id Folder to be deleted\n\t */\n\tFolders$1.prototype.delete_folder = function (folder_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/folder/${folder_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get all folder in space.\n\t * @param {String} space_id Space to search.\n\t * @param {Boolean} archived Search in archived folder\n\t */\n\tFolders$1.prototype.get_folders = function (space_id, archived) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/space/${space_id}/folder?archived=${archived}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get a folder\n\t * @param {String} folder_id Folder ID.\n\t */\n\tFolders$1.prototype.get_folder = function (folder_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/folder/${folder_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Folders_1 = Folders$1;\n\n\tvar Goals$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a goal\n\t * @param {String} team_id Team ID where goal be created\n\t * @param {JSON} data Body request for goal\n\t */\n\tGoals$1.prototype.create_goal = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/goal`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a goal\n\t * @param {String} goal_id Goal ID to be updated\n\t * @param {JSON} data Body request for goal\n\t */\n\tGoals$1.prototype.update_goal = function (goal_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/goal/${goal_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a Goal\n\t * @param {String} goal_id Goal ID to be deleted\n\t */\n\tGoals$1.prototype.delete_goal = function (goal_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/goal/${goal_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get all goals of a team\n\t * @param {String} team_id Team ID where search\n\t */\n\tGoals$1.prototype.get_goals = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/goal`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get info about a goal\n\t * @param {String} goal_id Goal ID to get info\n\t */\n\tGoals$1.prototype.get_goal = function (goal_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/goal/${goal_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create a key result\n\t * @param {String} goal_id Goal ID where key be created\n\t * @param {JSON} data Body request for create a key\n\t */\n\tGoals$1.prototype.create_key_result = function (goal_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/goal/${goal_id}/key_result`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a key result\n\t * @param {String} key_result_id Key result ID to be updated\n\t * @param {JSON} data Body request for update a key\n\t */\n\tGoals$1.prototype.edit_key_result = function (key_result_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/key_result/${key_result_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a key result\n\t * @param {String} key_result_id Key result ID to be deleted\n\t */\n\tGoals$1.prototype.delete_key_result = function (key_result_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/key_result/${key_result_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Goals_1 = Goals$1;\n\n\tvar Guests$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Invite a Guest to workspace\n\t * @param {String} team_id\n\t * @param {JSON} data\n\t */\n\tGuests$1.prototype.invite_guest_to_workspace = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/guest`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Edit a guest on workspace\n\t * @param {String} team_id\n\t * @param {String} guest_id\n\t * @param {JSON} data\n\t */\n\tGuests$1.prototype.edit_guest_on_workspace = function (team_id, guest_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/team/${team_id}/guest/${guest_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove Guest from workspace\n\t * @param {String} team_id\n\t * @param {String} guest_id\n\t */\n\tGuests$1.prototype.remove_guest_from_workspace = function (team_id, guest_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/team/${team_id}/guest/${guest_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get info about a Guest\n\t * @param {String} team_id\n\t * @param {String} guest_id\n\t */\n\tGuests$1.prototype.get_guest = function (team_id, guest_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/guest/${guest_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add a Guest to task\n\t * @param {String} task_id\n\t * @param {String} guest_id\n\t * @param {JSON} data\n\t */\n\tGuests$1.prototype.add_guest_to_task = function (task_id, guest_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/guest/${guest_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove Guest from task\n\t * @param {String} task_id\n\t * @param {String} guest_id\n\t */\n\tGuests$1.prototype.remove_guest_from_task = function (task_id, guest_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}/guest/${guest_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add guest in a list\n\t * @param {String} list_id\n\t * @param {String} guest_id\n\t * @param {Json} data\n\t */\n\tGuests$1.prototype.add_guest_to_list = function (list_id, guest_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/list/${list_id}/guest/${guest_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove Guest from a list\n\t * @param {String} list_id\n\t * @param {String} guest_id\n\t */\n\tGuests$1.prototype.remove_guest_from_list = function (list_id, guest_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/list/${list_id}/guest/${guest_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add Guest to folder\n\t * @param {String} folder_id\n\t * @param {String} guest_id\n\t * @param {JSON} data\n\t */\n\tGuests$1.prototype.add_guest_to_folder = function (folder_id, guest_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/folder/${folder_id}/guest/${guest_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove Guest from folder\n\t * @param {String} folder_id\n\t * @param {String} guest_id\n\t */\n\tGuests$1.prototype.remove_guest_from_folder = function (folder_id, guest_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/folder/${folder_id}/guest/${guest_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Guests_1 = Guests$1;\n\n\tvar Lists$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a list\n\t * @param {String} folder_id Folder id where a list be created\n\t * @param {JSON} data Body request for create a list\n\t */\n\tLists$1.prototype.create_list = function (folder_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/folder/${folder_id}/list`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create a list without a folder\n\t * @param {String} space_id Space ID where a list be created\n\t * @param {JSON} data Body request for create a list\n\t */\n\tLists$1.prototype.create_folderless_list = function (space_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/space/${space_id}/list`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a list\n\t * @param {String} list_id List ID to be updated\n\t * @param {JSON} data Body request for update a list\n\t */\n\tLists$1.prototype.update_list = function (list_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/list/${list_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a list\n\t * @param {String} list_id List ID to be deleted\n\t */\n\tLists$1.prototype.delete_list = function (list_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/list/${list_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t *\tGet lists from a folder\n\t * @param {String} folder_id Folder ID\n\t * @param {Boolean} archived Search in archived folders\n\t */\n\tLists$1.prototype.get_lists = function (folder_id, archived) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/folder/${folder_id}/list?archived=${archived}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get lists from a space\n\t * @param {String} space_id Space ID\n\t * @param {Boolean} archived Search in archived spaces\n\t */\n\tLists$1.prototype.get_folderless_lists = function (space_id, archived) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/space/${space_id}/list?archived=${archived}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get info about a list\n\t * @param {String} list_id List ID for informations\n\t */\n\tLists$1.prototype.get_list = function (list_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/list/${list_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add a task to an additional List\n\t * @param {String} list_id List ID\n\t * @param {String} task_id Task ID\n\t */\n\tLists$1.prototype.add_task_to_list = function (list_id, task_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/list/${list_id}/task/${task_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove Task From List\n\t * @param {String} list_id List ID where task on\n\t * @param {String} task_id Task ID to be deleted\n\t */\n\tLists$1.prototype.remove_task_from_list = function (list_id, task_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/list/${list_id}/task/${task_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Lists_1 = Lists$1;\n\n\tvar Members$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Get members on task.\n\t * @param {String} task_id Task ID\n\t */\n\tMembers$1.prototype.get_task_members = function (task_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/task/${task_id}/member`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get members on a list.\n\t * @param {String} list_id List ID\n\t */\n\tMembers$1.prototype.get_list_members = function (list_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/list/${list_id}/member`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Members_1 = Members$1;\n\n\tvar SharedHierarchy$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * See the shared hierarchy\n\t * @param {String} team_id Team id to be consulted\n\t */\n\tSharedHierarchy$1.prototype.get_shared_hierarchy = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/shared`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar SharedHierarchy_1 = SharedHierarchy$1;\n\n\tvar Spaces$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a space\n\t * @param {String} team_id Team ID where the space how be created\n\t * @param {JSON} data Body request for space\n\t */\n\tSpaces$1.prototype.create_space = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/space`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a space\n\t * @param {String} space_id Space ID to be updated\n\t * @param {JSON} data Body request for the update\n\t */\n\tSpaces$1.prototype.update_space = function (space_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/space/${space_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a space\n\t * @param {String} space_id Space to be deleted\n\t */\n\tSpaces$1.prototype.delete_space = function (space_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/space/${space_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get sapces\n\t * @param {String} team_id Team ID\n\t * @param {Boolean} archived Search in archived spaces\n\t */\n\tSpaces$1.prototype.get_spaces = function (team_id, archived) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/space?archived=${archived}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get info about a space\n\t * @param {String} space_id Space ID to be see\n\t */\n\tSpaces$1.prototype.get_space = function (space_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/space/${space_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Spaces_1 = Spaces$1;\n\n\tvar Tags$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Get all tags in space\n\t * @param {String} space_id Space ID\n\t */\n\tTags$1.prototype.get_space_tag = function (space_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/space/${space_id}/tag`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create a tag\n\t * @param {String} space_id Space ID where be created\n\t * @param {JSON} data Body request for tag\n\t */\n\tTags$1.prototype.create_space_tag = function (space_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/space/${space_id}/tag`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Edit a tag in space\n\t * @param {String} space_id Space ID where the tag is\n\t * @param {String} tag_name Tag to be updated\n\t * @param {JSPON} data Body request for tag\n\t */\n\tTags$1.prototype.edit_space_tag = function (space_id, tag_name, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/space/${space_id}/tag/${encodeURI(tag_name)}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a tag from space\n\t * @param {String} space_id Space ID where the tag is\n\t * @param {JSON} tag_name Tag to be deleted\n\t */\n\tTags$1.prototype.delete_space_tag = function (space_id, tag_name) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/space/${space_id}/tag/${encodeURI(tag_name)}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add a tag into a task\n\t * @param {String} task_id Task ID where tag be created\n\t * @param {String} tag_name Name of the tag\n\t */\n\tTags$1.prototype.add_tag_to_task = function (task_id, tag_name) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/tag/${encodeURI(tag_name)}`,\n\t\t\t\t\t{},\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove a tag from task\n\t * @param {String} task_id Task where the tag is\n\t * @param {String} tag_name Tag to be removed\n\t */\n\tTags$1.prototype.remove_tag_from_task = function (task_id, tag_name) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}/tag/${encodeURI(tag_name)}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Tags_1 = Tags$1;\n\n\tconst genParams$4 = params;\n\n\tvar TaskCheckList$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Add a new checklist to a task.\n\t * @param {String} task_id Task ID for the new checklist\n\t * @param {JSON} param Parameters for checklist\n\t * @param {JSON} data Object for new checklist\n\t */\n\tTaskCheckList$1.prototype.create_checklist = function (task_id, params, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$4(params, [\"task_id\"], [\"task_id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/checklist${param}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Rename a task checklist, or reorder a checklist so it appears above or below other checklists on a task\n\t * @param {String} checklist_id Checklist ID to be updated\n\t * @param {JSON}  data Object for the update Checklist\n\t */\n\tTaskCheckList$1.prototype.edit_checklist = function (checklist_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a checklist from a task.\n\t * @param {String} checklist_id Checklist to be deleted\n\t */\n\tTaskCheckList$1.prototype.delete_checklist = function (checklist_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Add a line item to a task checklist.\n\t * @param {String} checklist_id Checklist ID for the new item\n\t * @param {JSON} data Object with information for the new item\n\t */\n\tTaskCheckList$1.prototype.create_checklist_item = function (checklist_id, data) {\n\t\tthis.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}/checklist_item`,\n\t\t\t\t\tdata\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update an individual line item in a task checklist.\n\t * @param {String} checklist_id Task ID of reciver link\n\t * @param {String} checklist_item_id\n\t * @param {JSON}  data Parameters for link\n\t */\n\tTaskCheckList$1.prototype.edit_checklist_item = function (\n\t\tchecklist_id,\n\t\tchecklist_item_id,\n\t\tdata\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}/checklist_item/${checklist_item_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a line item from a task checklist.\n\t * @param {String} checklist_id Checklist where the item are\n\t * @param {String} checklist_item_id Checklist item do be deleted\n\t */\n\tTaskCheckList$1.prototype.delete_checklist_item = function (\n\t\tchecklist_id,\n\t\tchecklist_item_id\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/checklist/${checklist_id}/checklist_item/${checklist_item_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar TaskCheckList_1 = TaskCheckList$1;\n\n\tconst genParams$3 = params;\n\n\tvar TaskRelationships$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Set a task as waiting on or blocking another task.\n\t * @param {String} task_id Task ID to recive the dependency\n\t * @param {JSON} param Parameters for dependency\n\t * @param {JSON} data Dependency informatis\n\t */\n\tTaskRelationships$1.prototype.add_dependency = function (task_id, params, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$3(params, [\"task_id\"], [\"task_id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/dependency${param}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove the dependency relationship between two or more tasks.\n\t * @param {String} task_id Task ID to remove dependency\n\t * @param {JSON}  param Parameters for dependency\n\t */\n\tTaskRelationships$1.prototype.delete_dependency = function (task_id, params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$3(\n\t\t\t\t\tparams,\n\t\t\t\t\t[\"task_id\", \"depends_on\", \"dependency_of\"],\n\t\t\t\t\t[\"task_id\"]\n\t\t\t\t);\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}/dependency${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Link two tasks together.\n\t * @param {String} task_id Task ID of reciver link\n\t * @param {String} links_to\n\t * @param {JSON}  param Parameters for link\n\t */\n\tTaskRelationships$1.prototype.add_task_link = function (\n\t\ttask_id,\n\t\tlinks_to,\n\t\tparams\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$3(\n\t\t\t\t\tparams,\n\t\t\t\t\t[\"task_id\", \"links_to\"],\n\t\t\t\t\t[\"task_id\", \"links_to\"]\n\t\t\t\t);\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/task/${task_id}/link/${links_to}${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove the link between two tasks.\n\t * @param {String} task_id Task ID of reciver link\n\t * @param {String} links_to\n\t * @param {JSON}  param Parameters for link\n\t */\n\tTaskRelationships$1.prototype.delete_task_link = function (\n\t\ttask_id,\n\t\tlinks_to,\n\t\tparams\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$3(\n\t\t\t\t\tparams,\n\t\t\t\t\t[\"task_id\", \"links_to\"],\n\t\t\t\t\t[\"task_id\", \"links_to\"]\n\t\t\t\t);\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}/link/${links_to}${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar TaskRelationships_1 = TaskRelationships$1;\n\n\tconst genParams$2 = params;\n\n\tvar Tasks = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a Task\n\t * @param {String} list_id List ID where task be created\n\t * @param {JSON} data Body request for Task\n\t */\n\tTasks.prototype.create_task = function (list_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/list/${list_id}/task`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a Task\n\t * @param {String} task_id Task ID to be updated\n\t * @param {JSON} data Body request for update\n\t */\n\tTasks.prototype.update_task = function (task_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/task/${task_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a Task\n\t * @param {String} task_id Task ID to be deleted\n\t */\n\tTasks.prototype.delete_task = function (task_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/task/${task_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get info about a Task\n\t * @param {String} task_id Task ID\n\t */\n\tTasks.prototype.get_task = function (params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$2(params, [\"task_id\"], [\"task_id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/task/${params.task_id}${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get Tasks\n\t * @param {JSON} params Request parameters in JSON format\n\t */\n\tTasks.prototype.get_tasks = function (params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$2(params, [\"list_id\"], [\"list_id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/list/${params.list_id}/task${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Get Filtered Team Tasks\n\t * @param {JSON} params Request parameters in JSON format\n\t */\n\tTasks.prototype.get_filtered_team_tasks = function (params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$2(params, [\"team_Id\"], [\"team_Id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${params.team_Id}/task${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Get Task's Time in Status\n\t * @param {JSON} params Request parameters in JSON format\n\t */\n\tTasks.prototype.get_tasks_time_in_status = function (params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$2(params, [\"task_id\"], [\"task_id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/task/${params.task_id}/time_in_status${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Get Bulk Task's Time in Status\n\t * @param {JSON} params Request parameters in JSON format\n\t */\n\tTasks.prototype.get_bulk_tasks_time_in_status = function (params) {\n\t\t// If thers some bug, is because i can't test in my plan :(\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$2(params, [\"task_ids\"], [\"task_ids\"]);\n\t\t\t\tlet tasks_ids = \"?\";\n\t\t\t\tparams[\"task_ids\"].forEach((e) => {\n\t\t\t\t\ttasks_ids += `task_ids=${e}&`;\n\t\t\t\t});\n\t\t\t\ttasks_ids = tasks_ids.slice(0, -1);\n\t\t\t\tparam = param.replace(\"?\", \"\");\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/task/bulk_time_in_status/task_ids${tasks_ids}${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Get Tasks from a team\n\t * @param {JSON} params Request parameters in JSON format\n\t */\n\n\tTasks.prototype.get_team_tasks = function (params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$2(params, [\"list_id\", \"archived\"]);\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${params.team_id}/task?${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Tasks_1 = Tasks;\n\n\tvar TaskTemplates$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Consult the task templates from a team\n\t * @param {String} team_id Team ID to consult\n\t * @param {Int} page Page index\n\t */\n\tTaskTemplates$1.prototype.get_task_templates = function (team_id, page) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/taskTemplate?page=${page}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create task from template\n\t * @param {String} list_id List ID where it will be created\n\t * @param {String} template_id Template ID of the task\n\t * @param {JSON} data Task content\n\t */\n\tTaskTemplates$1.prototype.create_task_from_template = function (\n\t\tlist_id,\n\t\ttemplate_id,\n\t\tdata\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/list/${list_id}/taskTemplate/${template_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar TaskTemplates_1 = TaskTemplates$1;\n\n\tvar Teams$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\n\t/**\n\t * Create a Team\n\t * @param {String} team_id Team ID on Workspace\n\t * @param {JSON} data Body request for Team\n\t */\n\tTeams$1.prototype.create_team = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/team/${team_id}/group`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Update a Team\n\t * @param {String} group_id Group ID\n\t * @param {JSON} data Body request for Team\n\t */\n\tTeams$1.prototype.update_team = function (group_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/group/${group_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Update Team\n\t * @param {String} group_id Group ID to be delete\n\t */\n\tTeams$1.prototype.delete_team = function (group_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/group/${group_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Return all teams\n\t */\n\tTeams$1.prototype.get_teams = function () {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(`/api/v2/team`, token);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * View the used, total, and available member and guest seats for a Workspace.\n\t * @param {String} team_id\n\t */\n\tTeams$1.prototype.get_workspace_seats = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/seats`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Teams_1 = Teams$1;\n\n\tconst genParams$1 = params;\n\n\tvar TimeTracking$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t *\n\t * @param {JSON} params\n\t */\n\tTimeTracking$1.prototype.get_time_entries_within_date_range = function (params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet param = genParams$1(params, [\"team_id\"], [\"team_id\"]);\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${params.team_id}/time_entries${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t *\n\t * @param {String} team_id\n\t * @param {String} timer_id\n\t */\n\tTimeTracking$1.prototype.get_singular_time_entry = function (team_id, timer_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/${timer_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t *\n\t * @param {String} team_id\n\t */\n\tTimeTracking$1.prototype.get_running_time_entry = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/current`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create time entry\n\t * @param {String} team_id\n\t * @param {JSON} data\n\t */\n\tTimeTracking$1.prototype.create_time_entry = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Remove time entry\n\t * @param {String} team_id\n\t */\n\tTimeTracking$1.prototype.remove_tags_from_time_entries = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/tags`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get all time entries\n\t * @param {String} team_id\n\t */\n\tTimeTracking$1.prototype.get_all_tags_from_time_entries = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/tags`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t *\n\t * @param {String} team_id\n\t * @param {JSON} data\n\t */\n\tTimeTracking$1.prototype.add_tags_from_time_entries = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/tags`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t *\n\t * @param {String } team_id\n\t * @param {JSON} data\n\t */\n\tTimeTracking$1.prototype.change_tag_names_from_time_entries = function (\n\t\tteam_id,\n\t\tdata\n\t) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/tags`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t *\n\t * @param {String} team_id\n\t * @param {String} timer_id\n\t * @param {JSON} data\n\t */\n\tTimeTracking$1.prototype.start_time_entry = function (team_id, timer_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/start/${timer_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Stop time entry\n\t * @param {String} team_id\n\t */\n\tTimeTracking$1.prototype.stop_time_entry = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/v2/team/${team_id}/time_entries/stop`,\n\t\t\t\t\t{},\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete time entry\n\t * @param {String} team_id\n\t * @param {String} timer_id\n\t */\n\tTimeTracking$1.prototype.delete_time_entry = function (team_id, timer_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/${timer_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update time entry\n\t * @param {String} team_id\n\t * @param {String} timer_id\n\t * @param {JSON} data\n\t */\n\tTimeTracking$1.prototype.update_time_entry = function (team_id, timer_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/${timer_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get time entry history\n\t * @param {String} team_id\n\t * @param {String} timer_id\n\t */\n\tTimeTracking$1.prototype.get_time_entry_history = function (team_id, timer_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/time_entries/${timer_id}/history`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar TimeTracking_1 = TimeTracking$1;\n\n\tvar Users$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\n\t/**\n\t * Invite User To Workspace\n\t * @param {String} team_id Team ID where the user is gone be invited\n\t * @param {JSON} data Body request for User\n\t */\n\tUsers$1.prototype.invite_user_to_workspace = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/user`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Edit User On Workspace\n\t * @param {String} team_id Team ID where the user is gone be updated\n\t * @param {String} user_id User ID to be updated\n\t * @param {JSON} data Body request for User\n\t */\n\tUsers$1.prototype.edit_user_on_workspace = function (team_id, user_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/team/${team_id}/user/${user_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Remove User From Workspace\n\t * @param {String} team_id Team ID where the user is gone be deleted\n\t * @param {String} user_id User ID to be deleted\n\t */\n\tUsers$1.prototype.remove_user_from_workspace = function (team_id, user_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/team/${team_id}/user/${user_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Get User\n\t * @param {String} team_id Team ID where the user are\n\t * @param {String} user_id User ID to be returned\n\t */\n\tUsers$1.prototype.get_user = function (team_id, user_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/user/${user_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Users_1 = Users$1;\n\n\tconst genParams = params;\n\n\tvar Roles$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Get all tags in space\n\t * @param {team_id} Required\n\t * @param {String} include_members boolean\n\t */\n\tRoles$1.prototype.get_custom_roles = function (team_id, params) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\tlet param = genParams(params, [\"team_id\"], [\"team_id\"]);\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/team/${team_id}/customroles${param}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Roles_1 = Roles$1;\n\n\tvar Views$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a view for team\n\t * @param {String} team_id Team ID where the view be created\n\t * @param {JSON} data Body request for create a view\n\t */\n\tViews$1.prototype.create_team_view = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/view`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create a view for team\n\t * Alias from new version(create_team_view) to older(get_team_view)\n\t * @param {String} team_id Team ID where the view be created\n\t * @param {JSON} data Body request for create a view\n\t */\n\tViews$1.prototype.create_workspace_view = Views$1.prototype.create_team_view;\n\n\t/**\n\t * Create a view for space\n\t * @param {String} space_id Space ID where the view be created\n\t * @param {JSON} data Body request for create a view\n\t */\n\tViews$1.prototype.create_space_view = function (space_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/space/${space_id}/view`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create a view for folder\n\t * @param {String} folder_id Folder ID where the view be created\n\t * @param {JSON} data Body request for create a view\n\t */\n\tViews$1.prototype.create_folder_view = function (folder_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/folder/${folder_id}/view`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Create a view for list\n\t * @param {String} list_id List ID where the view be created\n\t * @param {JSON} data Body request for create a view\n\t */\n\tViews$1.prototype.create_list_view = function (list_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/list/${list_id}/view`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a view\n\t * @param {String} view_id View ID to be updated\n\t * @param {JSON} data Body request for update a view\n\t */\n\tViews$1.prototype.update_view = function (view_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/view/${view_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a view\n\t * @param {String} view_id View ID to be deleted\n\t */\n\tViews$1.prototype.delete_view = function (view_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/view/${view_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get view from team\n\t * @param {String} team_id Team ID\n\t */\n\tViews$1.prototype.get_team_view = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/view`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get view from team\n\t * Alias from new version (get_workspace_view) to older (get_team_view)\n\t * @param {String} team_id Team ID\n\t */\n\tViews$1.prototype.get_workspace_view = Views$1.prototype.get_team_view;\n\n\t/**\n\t * Get view from space\n\t * @param {String} space_id Space ID\n\t */\n\tViews$1.prototype.get_space_view = function (space_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/space/${space_id}/view`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get view from folder\n\t * @param {String} folder_id Folder ID\n\t */\n\tViews$1.prototype.get_folder_view = function (folder_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/folder/${folder_id}/view`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get view from list\n\t * @param {String} list_id List ID\n\t */\n\tViews$1.prototype.get_list_view = function (list_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/list/${list_id}/view`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get info about a view\n\t * @param {String} view_id View ID\n\t */\n\tViews$1.prototype.get_view = function (view_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/view/${view_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t *\tGet view tasks\n\t * @param {String} view_id View ID\n\t * @param {INT} page Index of a page\n\t */\n\tViews$1.prototype.get_view_tasks = function (view_id, page) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/view/${view_id}/task?page=${page}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Views_1 = Views$1;\n\n\tvar Webhooks$1 = function (token, request) {\n\t\tthis.token = token;\n\t\tthis.request = request;\n\t};\n\t/**\n\t * Create a webhook\n\t * @param {String} team_id Team where the webhook be created\n\t * @param {JSON} data Body request for webhook\n\t */\n\tWebhooks$1.prototype.create_webhook = function (team_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_post(\n\t\t\t\t\t`/api/v2/team/${team_id}/webhook`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Update a webhook\n\t * @param {String} webhook_id Webhook how be updated\n\t * @param {JSON} data Body request for update\n\t */\n\tWebhooks$1.prototype.update_webhook = function (webhook_id, data) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_put(\n\t\t\t\t\t`/api/v2/webhook/${webhook_id}`,\n\t\t\t\t\tdata,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Delete a webhook\n\t * @param {String} webhook_id Webhook how be deleted\n\t */\n\tWebhooks$1.prototype.delete_webhook = function (webhook_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_delete(\n\t\t\t\t\t`/api/v2/webhook/${webhook_id}`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Get all webhooks\n\t * @param {String} team_id Team ID\n\t */\n\tWebhooks$1.prototype.get_webhook = function (team_id) {\n\t\tvar token = this.token;\n\t\tvar request = this.request;\n\t\treturn new Promise(async function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tvar res = await request.https_clickupapi_get(\n\t\t\t\t\t`/api/v2/team/${team_id}/webhook`,\n\t\t\t\t\ttoken\n\t\t\t\t);\n\t\t\t\tresolve(res);\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar Webhooks_1 = Webhooks$1;\n\n\tvar _polyfillNode_crypto = {};\n\n\tvar _polyfillNode_crypto$1 = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tdefault: _polyfillNode_crypto\n\t});\n\n\tvar require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_crypto$1);\n\n\tvar _polyfillNode_fs = {};\n\n\tvar _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tdefault: _polyfillNode_fs\n\t});\n\n\tvar require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs$1);\n\n\tvar https = require$$0;\n\tvar crypto = require$$1;\n\tconst fs = require$$2;\n\n\tvar AttachmentReq = function (param) {\n\t\tthis.host = param.host;\n\t\tthis.port = param.port;\n\t\tthis.pathPrefix = param.pathPrefix;\n\t};\n\n\tAttachmentReq.prototype.post_task_attachment = function (\n\t\ttask_id,\n\t\tfile_path,\n\t\tfile_name,\n\t\tfile_content_type,\n\t\ttoken\n\t) {\n\t\tvar boundary =\n\t\t\t\"---WebKitFormBoundary\" + crypto.randomBytes(7).toString(\"hex\");\n\n\t\tvar option = {\n\t\t\tmethod: \"POST\",\n\t\t\thostname: this.host,\n\t\t\tport: this.port,\n\t\t\tpath: `${this.pathPrefix}/api/v2/task/${task_id}/attachment`,\n\t\t\theaders: {\n\t\t\t\tAuthorization: token,\n\t\t\t\t\"content-type\": `multipart/form-data; boundary=--${boundary}`,\n\t\t\t},\n\t\t};\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tconst req = https.request(option, function (res) {\n\t\t\t\tvar str = \"\";\n\t\t\t\tif (res.statusCode != 200) {\n\t\t\t\t\treject(res.statusCode);\n\t\t\t\t}\n\n\t\t\t\tres.on(\"data\", function (chunk) {\n\t\t\t\t\tstr += chunk;\n\t\t\t\t});\n\n\t\t\t\tres.on(\"end\", function () {\n\t\t\t\t\tresolve(JSON.parse(str));\n\t\t\t\t});\n\n\t\t\t\tres.on(\"error\", function (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treq.on(\"error\", function (err) {\n\t\t\t\treject(err);\n\t\t\t});\n\n\t\t\tvar postData = `----${boundary}\\r\\nContent-Disposition: form-data; name=\\\"attachment\\\"; filename=\\\"${file_path}\\\"\\r\\nContent-Type: \\\"${file_content_type}\\\"\\r\\n\\r\\n${fs.readFileSync(\n\t\t\tfile_path\n\t\t)}\\r\\n----${boundary}\\r\\nContent-Disposition: form-data; name=\\\"filename\\\"\\r\\n\\r\\n${file_name}\\r\\n----${boundary}--`;\n\n\t\t\treq.write(postData);\n\n\t\t\treq.end();\n\t\t});\n\t};\n\tvar Attachments$1 = AttachmentReq;\n\n\tconst Attachments = Attachments_1;\n\tconst Checklists = Checklists_1;\n\tconst Comments = Comments_1;\n\tconst CustomFields = CustomFields_1;\n\tconst Dependencies = Dependencies_1;\n\tconst Folders = Folders_1;\n\tconst Goals = Goals_1;\n\tconst Guests = Guests_1;\n\tconst Lists = Lists_1;\n\tconst Members = Members_1;\n\tconst SharedHierarchy = SharedHierarchy_1;\n\tconst Spaces = Spaces_1;\n\tconst Tags = Tags_1;\n\tconst TaskCheckList = TaskCheckList_1;\n\tconst TaskRelationships = TaskRelationships_1;\n\tconst Task = Tasks_1;\n\tconst TaskTemplates = TaskTemplates_1;\n\tconst Teams = Teams_1;\n\tconst TimeTracking = TimeTracking_1;\n\tconst Users = Users_1;\n\tconst Roles = Roles_1;\n\tconst Views = Views_1;\n\tconst Webhooks = Webhooks_1;\n\tconst Requests = requests;\n\tconst Attachment = Attachments$1;\n\n\tvar Clickup = function (token, requestParam) {\n\t\tthis.token = token;\n\t\tconst oRequestParam = requestParam || {\n\t\t\thost: \"api.clickup.com\",\n\t\t\tport: 443,\n\t\t\tpathPrefix: \"\",\n\t\t};\n\t\tconst oRequests = new Requests(oRequestParam);\n\t\tconst oAttachment = new Attachment(oRequestParam);\n\n\t\tthis.Attachments = new Attachments(this.token, oAttachment);\n\t\tthis.Checklists = new Checklists(this.token, oRequests);\n\t\tthis.Comments = new Comments(this.token, oRequests);\n\t\tthis.CustomFields = new CustomFields(this.token, oRequests);\n\t\tthis.Dependencies = new Dependencies(this.token, oRequests);\n\t\tthis.Folders = new Folders(this.token, oRequests);\n\t\tthis.Goals = new Goals(this.token, oRequests);\n\t\tthis.Guests = new Guests(this.token, oRequests);\n\t\tthis.Lists = new Lists(this.token, oRequests);\n\t\tthis.Members = new Members(this.token, oRequests);\n\t\tthis.SharedHierarchy = new SharedHierarchy(this.token, oRequests);\n\t\tthis.Spaces = new Spaces(this.token, oRequests);\n\t\tthis.Tags = new Tags(this.token, oRequests);\n\t\tthis.TaskCheckList = new TaskCheckList(this.token, oRequests);\n\t\tthis.TaskRelationships = new TaskRelationships(this.token, oRequests);\n\t\tthis.Tasks = new Task(this.token, oRequests);\n\t\tthis.TaskTemplates = new TaskTemplates(this.token, oRequests);\n\t\tthis.Teams = new Teams(this.token, oRequests);\n\t\tthis.TimeTracking = new TimeTracking(this.token, oRequests);\n\t\tthis.Users = new Users(this.token, oRequests);\n\t\tthis.Roles = new Roles(this.token, oRequests);\n\t\tthis.Views = new Views(this.token, oRequests);\n\t\tthis.Webhooks = new Webhooks(this.token, oRequests);\n\t};\n\n\tvar src = Clickup;\n\n\ttry { Object.defineProperty(src, \"__\" + \"esModule\", { value: true }); src.default = src; } catch (ex) {}\n\n\treturn src;\n\n}));\n"
    }
  ]
}